<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kmp+</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
	<script src="d3.v7.min.js"></script>
    <style>
        :root {
            --primary: #325980;
            --secondary: #3498db;
            --light-gray: #f5f5f5;
            --off-white: #f1f1f1;
            --white: #ffffff;
            --shadow: 0 4px 6px rgba(50, 89, 128, 0.1);
            --text-color: #333;
            --header-bg: #325980;
            --header-text: #ffffff;
            --footer-bg: #325980;
            --footer-text: #ffffff;
            --panel-bg: #ffffff;
            --panel-border: rgba(50, 89, 128, 0.1);
            --btn-bg: #f1f1f1;
            --btn-text: #325980;
            --btn-hover-bg: #3498db;
            --btn-hover-text: #ffffff;
            --btn-active-bg: #325980;
            --btn-active-text: #ffffff;
			--primary-color: #3e76ad;
		--header-text-color: #ffffff;
		--border-radius: 8px;
        }
        
        [data-theme="dark"] {
            --primary: #1a3a5f;
            --secondary: #2980b9;
            --light-gray: #222;
            --off-white: #333;
            --white: #282828;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            --text-color: #eee;
            --header-bg: #1a3a5f;
            --header-text: #ffffff;
            --footer-bg: #1a3a5f;
            --footer-text: #ffffff;
            --panel-bg: #333;
            --panel-border: rgba(0, 0, 0, 0.2);
            --btn-bg: #444;
            --btn-text: #eee;
            --btn-hover-bg: #2980b9;
            --btn-hover-text: #ffffff;
            --btn-active-bg: #1a3a5f;
            --btn-active-text: #ffffff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        body {
            background-color: var(--light-gray);
            color: var(--text-color);
            line-height: 1.6;
        }
        
        header {
            background-color: var(--primary-color);
            color: var(--header-text-color);
            padding: 20px 0;
            text-align: center;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            background-image: linear-gradient(135deg, var(--primary-color) 0%, #2c3e50 100%);
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-weight: 300;
            font-size: 1.1rem;
        }
        
        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .vis-container {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            margin-bottom: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .sticky-controls {
            position: sticky;
            top: 0;
            z-index: 1000;
            background-color: var(--panel-bg);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow);
            width: 100%;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
        }
        
        .control-btn {
            background-color: var(--btn-bg);
            border: none;
            color: var(--btn-text);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .control-btn:hover {
            background-color: var(--btn-hover-bg);
            color: var(--btn-hover-text);
        }
        
        .control-btn.active {
            background-color: var(--btn-active-bg);
            color: var(--btn-active-text);
        }
        
        .theme-toggle {
            font-size: 1.2rem;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--btn-text);
            margin-left: auto;
        }
        
        #visualization {
            width: 100%;
            height: 600px;
            position: relative;
        }
        
        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .node:hover {
            stroke: var(--primary);
            stroke-width: 2px;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        
        .definition-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px;
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: var(--shadow);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            max-height: 580px;
            overflow-y: auto;
            color: var(--text-color);
        }
        
        .definition-panel h3 {
            color: var(--secondary);
            margin-bottom: 0.5rem;
            border-bottom: 2px solid var(--secondary);
            padding-bottom: 0.5rem;
        }
        
        .definition-panel p {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
        
        .tooltip {
            position: absolute;
            background-color: var(--panel-bg);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: var(--shadow);
            color: var(--text-color);
        }
        
        .info-box {
            background-color: var(--off-white);
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
            border-left: 4px solid var(--secondary);
        }
        
        .info-box h3 {
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .similarity-scale {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            margin-top: 1rem;
        }
        
        .scale-gradient {
            height: 20px;
            width: 80%;
            margin: 0 10px;
            background: linear-gradient(to right, var(--off-white), var(--secondary));
            border-radius: 4px;
        }
        
        /* Стили для модальных окон */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
        }
        
        .modal-content {
            background-color: var(--panel-bg);
            padding: 2rem;
            border-radius: 8px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            color: var(--text-color);
            box-shadow: var(--shadow);
            position: relative;
        }
        
        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-color);
        }
        
        .definition-list {
            list-style-type: none;
            padding: 0;
        }
        
        .definition-list li {
            padding: 0.8rem;
            border-bottom: 1px solid var(--panel-border);
        }
        
        .definition-list li:last-child {
            border-bottom: none;
        }
        
        .definition-type {
            font-weight: bold;
            color: var(--secondary);
            display: block;
            margin-bottom: 0.5rem;
        }
        
        .definition-category {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
        }
        
        .category-category {
            background-color: rgba(228, 26, 28, 0.2);
            color: #e41a1c;
        }
        
        .category-object {
            background-color: rgba(55, 126, 184, 0.2);
            color: #377eb8;
        }
        
        .category-audience {
            background-color: rgba(77, 175, 74, 0.2);
            color: #4daf4a;
        }
        
        .tab-buttons {
            display: flex;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--panel-border);
        }
        
        .tab-btn {
            padding: 0.5rem 1rem;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-color);
            font-weight: 500;
            opacity: 0.7;
            border-bottom: 3px solid transparent;
        }
        
        .tab-btn.active {
            opacity: 1;
            border-bottom: 3px solid var(--secondary);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        footer {
      text-align: center;
      padding: 20px 0;
      margin-top: 40px;
      font-size: 0.9rem;
      border-top: 1px solid #ddd;
    }
        
        @media (max-width: 768px) {
            main {
                padding: 1rem;
            }
            
            .definition-panel {
                width: 100%;
                position: static;
                margin-top: 1rem;
                opacity: 1;
                pointer-events: auto;
            }
            
            #visualization {
                height: 400px;
            }
            
            .controls {
                gap: 0.5rem;
            }
            
            .control-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.9rem;
            }
            
            .modal-content {
                width: 95%;
                padding: 1rem;
            }
        }
		ul {
    padding-left: 20px; /* Увеличивает отступ внутри списка */
}

    </style>
</head>
<body>
    <header>
        <h1>Глубокое обучение</h1>
        <p class="subtitle">Интерактивная визуализация семантического сходства дефиниций</p>
    </header>
    
    <main>
        <div class="vis-container">
            <div class="sticky-controls">
                <div class="controls">
                    <button class="control-btn active" data-view="force">Граф связей</button>
                    <button class="control-btn" data-view="cluster">Кластеризация</button>
                    <button class="control-btn" data-view="radial">Радиальное представление</button>
                    <button class="control-btn" id="definitionsBtn">Список определений</button>
                    <button class="control-btn" id="infoBtn">О приложении</button>
                    <button class="theme-toggle" id="themeToggle">🌙</button>
                </div>
            </div>
            
            <div id="visualization">
                <div class="definition-panel" id="definitionPanel">
                    <h3>Выберите определение</h3>
                    <p>Нажмите на любой узел графа, чтобы увидеть полное определение эмбеддинга и его связи с другими определениями.</p>
                </div>
                <div class="tooltip" id="tooltip"></div>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e41a1c;"></div>
                    <span>По категориям</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #377eb8;"></div>
                    <span>По объектам</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4daf4a;"></div>
                    <span>По аудитории</span>
                </div>
            </div>
            
            <div class="similarity-scale">
                <span>Низкое сходство</span>
                <div class="scale-gradient"></div>
                <span>Высокое сходство</span>
            </div>
            
            <div class="info-box">
                <h3>О визуализации</h3>
                <p>Показаны семантические связи между различными определениями эмбеддинга. Чем ближе расположены узлы, тем больше семантическое сходство между определениями. Толщина линий также отражает степень сходства.</p>
                <p>Попробуйте разные режимы визуализации, чтобы увидеть различные аспекты взаимосвязей между определениями.</p>
            </div>
        </div>
    </main>

    <!-- Модальное окно со списком определений -->
    <div id="definitionsModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="closeDefinitionsModal">&times;</span>
            <h2>Список определений эмбеддинга</h2>
            <ul class="definition-list" id="definitionsList">
                <!-- Определения будут добавлены через JavaScript -->
            </ul>
        </div>
    </div>

    <!-- Модальное окно с информацией о приложении -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="closeInfoModal">&times;</span>
            <h2>О приложении</h2>
            
            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="functionalities">Функциональные возможности</button>
                <button class="tab-btn" data-tab="didactic">Дидактическая значимость</button>
                <button class="tab-btn" data-tab="technologies">Использованные технологии</button>
                <button class="tab-btn" data-tab="instructions">Инструкция для студентов</button>
            </div>
            
            <div id="functionalities" class="tab-content active">
                <h3>Функциональные возможности</h3>
                <p>Приложение предоставляет следующие возможности:</p>
                <ul>
                    <li>Визуализация семантических связей между различными определениями эмбеддинга</li>
                    <li>Три режима визуализации:
                        <ul>
                            <li><b>Граф связей</b> - демонстрирует прямые связи между определениями и их силу</li>
                            <li><b>Кластеризация</b> - группирует определения по категориям в визуально понятные кластеры</li>
                            <li><b>Радиальное представление</b> - располагает определения на концентрических окружностях по категориям</li>
                        </ul>
                    </li>
                    <li>Интерактивное взаимодействие с определениями через клики и наведение</li>
                    <li>Детальный просмотр каждого определения и его семантических связей с другими</li>
                    <li>Возможность переключения между светлой и темной темами</li>
                    <li>Адаптивный дизайн для мобильных устройств</li>
                </ul>
            </div>
            
            <div id="didactic" class="tab-content">
                <h3>Дидактическая значимость</h3>
                <p>Приложение имеет значительную дидактическую ценность для студентов-филологов и лингвистов:</p>
                <ul>
                    <li>Наглядная демонстрация семантических связей между различными определениями одного понятия</li>
                    <li>Формирование понимания многогранности и контекстуальной зависимости лингвистических терминов</li>
                    <li>Развитие критического мышления при анализе различных формулировок определений</li>
                    <li>Иллюстрация принципов векторной семантики на практическом примере</li>
                    <li>Возможность изучения влияния целевой аудитории на формулировку определений</li>
                    <li>Поддержка исследовательской деятельности студентов в области компьютерной лингвистики</li>
                    <li>Демонстрация междисциплинарных связей лингвистики, математики и компьютерных наук</li>
                </ul>
            </div>
            
            <div id="technologies" class="tab-content">
                <h3>Использованные технологии:</h3>
                <ul>
                    <li><b>HTML5, CSS3, JavaScript</b> - основа веб-приложения</li>
                    <li><b>D3.js (V.7)</b> - JavaScript-библиотека для создания интерактивных визуализаций данных</li>
                    <li><b>Векторные представления</b> - для моделирования семантического сходства между определениями</li>
                    <li><b>Алгоритмы визуализации графов</b>:
                        <ul>
                            <li>Force-directed graph layout - для интуитивного отображения связей</li>
                            <li>Кластеризация (Pack layout) - для группировки связанных определений</li>
                            <li>Радиальные алгоритмы - для упорядоченного представления данных</li>
                        </ul>
                    </li>
                    <li><b>Responsive design</b> - для корректного отображения на различных устройствах</li>
                    <li><b>CSS Variables</b> - для реализации переключения между темными и светлыми темами</li>
                </ul>
            </div>
            
            <div id="instructions" class="tab-content">
                <h3>Инструкция для студентов</h3>
                <ol>
                    <li><b>Начало работы</b>:
                        <ul>
                            <li>При загрузке страницы вы увидите граф связей между различными определениями эмбеддинга</li>
                            <li>Цвета узлов соответствуют различным категориям определений (по категориям, по объектам, по аудитории)</li>
                        </ul>
                    </li>
                    <li><b>Взаимодействие с визуализацией</b>:
                        <ul>
                            <li>Наведите курсор на узел, чтобы увидеть его название и выделить связи</li>
                            <li>Щелкните на узел, чтобы просмотреть полное определение и его семантические связи с другими</li>
                            <li>Перетаскивайте узлы для лучшего расположения графа</li>
                        </ul>
                    </li>
                    <li><b>Изменение режима визуализации</b>:
                        <ul>
                            <li>Используйте кнопки в верхней части экрана для переключения между различными представлениями</li>
                            <li>Каждый режим подчеркивает разные аспекты взаимосвязей между определениями</li>
                        </ul>
                    </li>
                    <li><b>Изучение определений</b>:
                        <ul>
                            <li>Нажмите "Список определений" для просмотра всех определений эмбеддинга</li>
                            <li>Обратите внимание на различия в формулировках в зависимости от категории и целевой аудитории</li>
                        </ul>
                    </li>
                    <li><b>Учебные задания</b>:
                        <ul>
                            <li>Определите, какие аспекты понятия "эмбеддинг" присутствуют во всех определениях</li>
                            <li>Проанализируйте, как меняется формулировка в зависимости от целевой аудитории</li>
                            <li>Сравните определения внутри одной категории и между разными категориями</li>
                            <li>Создайте собственное определение эмбеддинга и сравните его с представленными</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </div>
    </div>

    <footer class="footer">
<div class="container">
<p>© 2025 | kmp | CC BY-NC-SA 4.0<br>
Разработано для студентов БрГУ имени А.С. Пушкина</p>
</div>
</div>
</footer>
<div style="position: fixed; bottom: 10px; right: 33px; opacity: 0.3; font-size: 14px;">kmp+</div>
    

    <script>
// Данные определений Глубокого обучения
const definitions = [
    // Категория "category" (общие определения)
    {
        id: 1,
        category: "category",
        type: "Математическое",
        text: "Глубокое обучение — это класс алгоритмов машинного обучения, использующих многослойные нейронные сети для автоматического выделения иерархических признаков из данных."
    },
    {
        id: 2,
        category: "category",
        type: "Техническое",
        text: "Глубокое обучение — это подраздел машинного обучения, основанный на искусственных нейронных сетях с множеством скрытых слоёв, способных моделировать сложные нелинейные зависимости."
    },
    {
        id: 3,
        category: "category",
        type: "Практическое",
        text: "Глубокое обучение — это технология, позволяющая компьютерам автоматически обучаться на большом количестве примеров без явного программирования, особенно эффективная для задач распознавания образов."
    },
    {
        id: 4,
        category: "category",
        type: "Историческое",
        text: "Глубокое обучение — это возрождённая в 2010-х годах концепция нейросетей с многослойной структурой, ставшая возможной благодаря увеличению вычислительных мощностей и появлению больших данных."
    },
    {
        id: 5,
        category: "category",
        type: "Футуристическое",
        text: "Глубокое обучение — это шаг к созданию искусственных когнитивных систем, способных к самообучению и генерации знаний без человеческого вмешательства."
    },
    
    // Категория "object" (типы архитектур)
    {
        id: 6,
        category: "object",
        type: "CNN (Свёрточные сети)",
        text: "Свёрточные нейронные сети — это архитектура глубокого обучения, специализированная для обработки изображений через применение локальных фильтров и постепенное абстрагирование признаков."
    },
    {
        id: 7,
        category: "object",
        type: "RNN (Рекуррентные сети)",
        text: "Рекуррентные нейронные сети — это класс нейросетей с циклами, предназначенный для обработки последовательных данных (текст, речь, временные ряды) с учётом временных зависимостей."
    },
    {
        id: 8,
        category: "object",
        type: "Transformer",
        text: "Трансформеры — это архитектура на основе механизма внимания, заменившая RNN в большинстве задач NLP благодаря способности анализировать глобальные зависимости в данных."
    },
    {
        id: 9,
        category: "object",
        type: "GAN (Состязательные сети)",
        text: "Генеративно-состязательные сети — это система из двух конкурирующих нейросетей (генератора и дискриминатора), обучающихся создавать реалистичные синтетические данные."
    },
    {
        id: 10,
        category: "object",
        type: "Autoencoder",
        text: "Автоэнкодеры — это нейросети, обучающиеся эффективному представлению данных через их сжатие и последующее восстановление с минимальными потерями информации."
    },
    
    // Категория "audience" (для разной аудитории)
    {
        id: 11,
        category: "audience",
        type: "Для школьника",
        text: "Глубокое обучение — это когда компьютер учится сам, как маленький ребёнок, разглядывая много картинок или читая книги, и со временем начинает понимать, что на них изображено."
    },
    {
        id: 12,
        category: "audience",
        type: "Для студента",
        text: "Глубокое обучение — это метод машинного обучения, где многослойные нейронные сети автоматически извлекают признаки из сырых данных, минимизируя необходимость в ручной feature engineering."
    },
    {
        id: 13,
        category: "audience",
        type: "Для профессора",
        text: "Глубокое обучение — это неконвексная оптимизация в пространствах сверхвысокой размерности, где композиция нелинейных преобразований позволяет аппроксимировать сложные функциональные зависимости."
    }
];

// Функция для вычисления "семантического сходства" между определениями
function calculateSimilarity(def1, def2) {
    const text1 = def1.text.toLowerCase();
    const text2 = def2.text.toLowerCase();
    
    let baseSimilarity = def1.category === def2.category ? 0.5 : 0.2;
    
    // Ключевые слова для Deep Learning
    const keywords = [
        "нейронн", "сеть", "обучен", "слой", "данн", "признак", 
        "машинн", "модел", "архитектур", "оптим", "изображен", 
        "последовательн", "временн", "трансформер", "вниман", "свёртк",
        "рекуррент", "генератив", "автоэнкод", "градиент"
    ];
    
    let commonKeywords = 0;
    keywords.forEach(keyword => {
        if (text1.includes(keyword) && text2.includes(keyword)) {
            commonKeywords++;
        }
    });
    
    const keywordSimilarity = commonKeywords / keywords.length;
    return baseSimilarity + (1 - baseSimilarity) * keywordSimilarity;
}

        // Создание графа связей между определениями
        function createGraph() {
            const nodes = definitions.map(def => ({
                id: def.id,
                name: def.type,
                category: def.category,
                text: def.text
            }));
            
            const links = [];
            
            // Создание связей между всеми парами определений
            for (let i = 0; i < definitions.length; i++) {
                for (let j = i + 1; j < definitions.length; j++) {
                    const similarity = calculateSimilarity(definitions[i], definitions[j]);
                    // Добавляем связь только если сходство выше порогового значения
                    if (similarity > 0.3) {
                        links.push({
                            source: definitions[i].id,
                            target: definitions[j].id,
                            value: similarity
                        });
                    }
                }
            }
            
            return { nodes, links };
        }

        // Инициализация визуализации
        function initVisualization() {
            const width = document.getElementById('visualization').clientWidth;
            const height = document.getElementById('visualization').clientHeight;
            const graph = createGraph();
            
            // Создание SVG-элемента
            const svg = d3.select('#visualization')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', [0, 0, width, height])
                .attr('style', 'max-width: 100%; height: auto;');
            
            // Определение цветов для категорий
            const color = d3.scaleOrdinal()
                .domain(['category', 'object', 'audience'])
                .range(['#e41a1c', '#377eb8', '#4daf4a']);
            
            // Создание симуляции для силового графа
            const simulation = d3.forceSimulation(graph.nodes)
                .force('link', d3.forceLink(graph.links).id(d => d.id).distance(d => 200 * (1 - d.value)))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(50));
            
            // Создание связей (линий)
            const link = svg.append('g')
                .selectAll('line')
                .data(graph.links)
                .join('line')
                .attr('class', 'link')
                .attr('stroke-width', d => 2 + 8 * d.value)
                .attr('opacity', d => 0.2 + 0.8 * d.value);
            
            // Создание узлов (кружков)
            const node = svg.append('g')
                .selectAll('circle')
                .data(graph.nodes)
                .join('circle')
                .attr('class', 'node')
                .attr('r', 12)
                .attr('fill', d => color(d.category))
                .call(drag(simulation));
            
            // Добавление подписей к узлам
            const label = svg.append('g')
                .selectAll('text')
                .data(graph.nodes)
                .join('text')
                .attr('dx', 15)
                .attr('dy', 4)
                .text(d => d.name)
                .style('font-size', '12px')
                .style('pointer-events', 'none');
            
            // Обработка событий узлов
            node.on('mouseover', function(event, d) {
                // Подсветка узла при наведении
                d3.select(this)
                    .attr('stroke', '#000')
                    .attr('stroke-width', 2);
                
                // Подсветка связанных узлов и связей
                const connectedLinks = graph.links.filter(l => l.source.id === d.id || l.target.id === d.id);
                const connectedNodeIds = new Set();
                
                connectedLinks.forEach(l => {
                    connectedNodeIds.add(l.source.id);
                    connectedNodeIds.add(l.target.id);
                    
                    d3.select(link.nodes()[graph.links.indexOf(l)])
                        .attr('stroke', '#000')
                        .attr('stroke-width', l => 4 + 8 * l.value)
                        .attr('opacity', 1);
                });
                
                node.filter(n => connectedNodeIds.has(n.id) && n.id !== d.id)
                    .attr('stroke', '#666')
                    .attr('stroke-width', 1.5);
                
                // Показ всплывающей подсказки
                const tooltip = d3.select('#tooltip')
                    .style('opacity', 1)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                
                tooltip.html(`<strong>${d.name}</strong>`);
            })
            .on('mouseout', function() {
                // Возврат к обычному виду при уходе курсора
                d3.select(this)
                    .attr('stroke', null);
                
                link.attr('stroke', '#999')
                    .attr('stroke-width', d => 2 + 8 * d.value)
                    .attr('opacity', d => 0.2 + 0.8 * d.value);
                
                node.attr('stroke', null);
                
                d3.select('#tooltip').style('opacity', 0);
            })
            .on('click', function(event, d) {
                // Показ панели с полным определением
                const panel = d3.select('#definitionPanel');
                
                panel.style('opacity', 1)
                    .html(`
                        <h3>${d.name}</h3>
                        <p>${d.text}</p>
                        <p><strong>Категория:</strong> ${d.category === 'category' ? 'По категориям' : d.category === 'object' ? 'По объектам' : 'По аудитории'}
                        </p>
                        <h4>Семантические связи:</h4>
                    `);
                
                // Добавление информации о связанных определениях
                const connectedLinks = graph.links.filter(l => l.source.id === d.id || l.target.id === d.id)
                    .sort((a, b) => b.value - a.value);
                
                if (connectedLinks.length > 0) {
                    const relatedList = panel.append('ul')
                        .style('padding-left', '20px');
                    
                    connectedLinks.forEach(link => {
                        const relatedNode = link.source.id === d.id ? link.target : link.source;
                        const similarity = Math.round(link.value * 100);
                        
                        relatedList.append('li')
                            .html(`<strong>${relatedNode.name}</strong> (сходство: ${similarity}%)`);
                    });
                } else {
                    panel.append('p')
                        .text('Нет сильных семантических связей с другими определениями.');
                }
            });
            
            // Обновление позиций элементов при каждом "тике" симуляции
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x = Math.max(20, Math.min(width - 20, d.x)))
                    .attr('cy', d => d.y = Math.max(20, Math.min(height - 20, d.y)));
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Функция для перетаскивания узлов
            function drag(simulation) {
                function dragstarted(event) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                }
                
                function dragged(event) {
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                }
                
                function dragended(event) {
                    if (!event.active) simulation.alphaTarget(0);
                    event.subject.fx = null;
                    event.subject.fy = null;
                }
                
                return d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended);
            }
            
            // Возвращаем объекты для возможности переключения вида
            return {
                svg,
                simulation,
                graph,
                node,
                link,
                label,
                width,
                height
            };
        }

        // Функция для кластеризации определений
        function showClusterView(vis) {
            // Останавливаем предыдущую симуляцию
            vis.simulation.stop();
            
            // Очищаем SVG
            vis.svg.selectAll('*').remove();
            
            // Создаем иерархическую структуру для кластеризации
            const clusters = {
                name: 'Определения эмбеддинга',
                children: [
                    {
                        name: 'По категориям',
                        children: vis.graph.nodes.filter(n => n.category === 'category')
                    },
                    {
                        name: 'По объектам',
                        children: vis.graph.nodes.filter(n => n.category === 'object')
                    },
                    {
                        name: 'По аудитории',
                        children: vis.graph.nodes.filter(n => n.category === 'audience')
                    }
                ]
            };
            
            // Создаем иерархию и разметку для круговой диаграммы
            const root = d3.hierarchy(clusters)
                .sum(() => 1);
            
            const pack = d3.pack()
                .size([vis.width - 40, vis.height - 40])
                .padding(3);
            
            pack(root);
            
            // Определение цветов для категорий
            const color = d3.scaleOrdinal()
                .domain(['category', 'object', 'audience'])
                .range(['#e41a1c', '#377eb8', '#4daf4a']);
            
            // Создаем контейнер для всей визуализации
            const container = vis.svg.append('g')
                .attr('transform', `translate(20, 20)`);
            
            // Добавляем круги для кластеров и узлов
            const node = container.selectAll('g')
                .data(root.descendants())
                .join('g')
                .attr('transform', d => `translate(${d.x}, ${d.y})`);
            
            node.append('circle')
                .attr('r', d => d.r)
                .attr('fill', d => d.depth === 0 ? 'white' : d.depth === 1 ? '#f8f8f8' : color(d.data.category))
                .attr('stroke', d => d.depth === 0 ? 'none' : d.depth === 1 ? '#ccc' : '#666')
                .attr('stroke-width', d => d.depth === 0 ? 0 : 1)
                .attr('opacity', d => d.depth === 0 ? 0 : 1);
            
            // Добавляем подписи
            node.filter(d => d.depth > 0)
                .append('text')
                .attr('dy', d => d.depth === 1 ? 0 : 4)
                .attr('text-anchor', 'middle')
                .attr('font-size', d => d.depth === 1 ? '14px' : '10px')
                .attr('font-weight', d => d.depth === 1 ? 'bold' : 'normal')
                .text(d => d.depth === 1 ? d.data.name : d.data.name.length > 15 ? d.data.name.substring(0, 15) + '...' : d.data.name);
            
            // Добавляем обработчики событий
            node.filter(d => d.depth === 2)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    d3.select(this).select('circle')
                        .attr('stroke', '#000')
                        .attr('stroke-width', 2);
                    
                    // Показ всплывающей подсказки
                    const tooltip = d3.select('#tooltip')
                        .style('opacity', 1)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                    
                    tooltip.html(`<strong>${d.data.name}</strong>`);
                })
                .on('mouseout', function() {
                    d3.select(this).select('circle')
                        .attr('stroke', '#666')
                        .attr('stroke-width', 1);
                    
                    d3.select('#tooltip').style('opacity', 0);
                })
                .on('click', function(event, d) {
                    // Показ панели с полным определением
                    const panel = d3.select('#definitionPanel');
                    
                    panel.style('opacity', 1)
                        .html(`
                            <h3>${d.data.name}</h3>
                            <p>${d.data.text}</p>
                            <p>
                            <strong>Категория:</strong> ${d.data.category === 'category' ? 'По категориям' : d.data.category === 'object' ? 'По объектам' : 'По аудитории'}
                            </p>
                            <h4>Семантические связи:</h4>
                        `);
                    
                    // Добавление информации о связанных определениях
                    const connectedLinks = vis.graph.links.filter(l => l.source.id === d.data.id || l.target.id === d.data.id)
                        .sort((a, b) => b.value - a.value);
                    
                    if (connectedLinks.length > 0) {
                        const relatedList = panel.append('ul')
                            .style('padding-left', '20px');
                        
                        connectedLinks.forEach(link => {
                            const relatedNode = link.source.id === d.data.id ? link.target : link.source;
                            const similarity = Math.round(link.value * 100);
                            
                            relatedList.append('li')
                                .html(`<strong>${relatedNode.name}</strong> (сходство: ${similarity}%)`);
                        });
                    } else {
                        panel.append('p')
                            .text('Нет сильных семантических связей с другими определениями.');
                    }
                });
        }

        // Функция для радиального представления
        function showRadialView(vis) {
            // Останавливаем предыдущую симуляцию
            vis.simulation.stop();
            
            // Очищаем SVG
            vis.svg.selectAll('*').remove();
            
            const width = vis.width;
            const height = vis.height;
            const radius = Math.min(width, height) / 2 - 80;
            
            // Определение цветов для категорий
            const color = d3.scaleOrdinal()
                .domain(['category', 'object', 'audience'])
                .range(['#e41a1c', '#377eb8', '#4daf4a']);
            
            // Создаем группу для центрирования визуализации
            const g = vis.svg.append('g')
                .attr('transform', `translate(${width / 2}, ${height / 2})`);
            
            // Создаем радиальную силовую симуляцию
            const simulation = d3.forceSimulation(vis.graph.nodes)
                .force('link', d3.forceLink(vis.graph.links).id(d => d.id).distance(d => 100 * (1 - d.value)))
                .force('charge', d3.forceManyBody().strength(-100))
                .force('center', d3.forceCenter(0, 0))
                .force('collision', d3.forceCollide().radius(30))
                .force('radial', d3.forceRadial(d => {
                    if (d.category === 'category') return radius * 0.4;
                    if (d.category === 'object') return radius * 0.7;
                    return radius;
                }));
            
            // Создание связей (линий)
            const link = g.append('g')
                .selectAll('line')
                .data(vis.graph.links)
                .join('line')
                .attr('class', 'link')
                .attr('stroke-width', d => 1 + 5 * d.value)
                .attr('opacity', d => 0.2 + 0.8 * d.value);
            
            // Создание узлов (кружков)
            const node = g.append('g')
                .selectAll('circle')
                .data(vis.graph.nodes)
                .join('circle')
                .attr('class', 'node')
                .attr('r', 10)
                .attr('fill', d => color(d.category))
                .call(drag(simulation));
            
            // Добавление подписей к узлам
            const label = g.append('g')
                .selectAll('text')
                .data(vis.graph.nodes)
                .join('text')
                .attr('dx', 12)
                .attr('dy', 4)
                .text(d => d.name)
                .style('font-size', '10px')
                .style('pointer-events', 'none');
            
            // Добавление круговых направляющих для категорий
            const categoryGuides = [
                { name: 'По категориям', radius: radius * 0.4, color: '#e41a1c' },
                { name: 'По объектам', radius: radius * 0.7, color: '#377eb8' },
                { name: 'По аудитории', radius: radius, color: '#4daf4a' }
            ];
            
            g.selectAll('.guide')
                .data(categoryGuides)
                .join('circle')
                .attr('class', 'guide')
                .attr('r', d => d.radius)
                .attr('fill', 'none')
                .attr('stroke', d => d.color)
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '3,3')
                .attr('opacity', 0.5);
            
            // Добавление подписей к направляющим
            g.selectAll('.guide-label')
                .data(categoryGuides)
                .join('text')
                .attr('class', 'guide-label')
                .attr('y', d => -d.radius - 5)
                .attr('text-anchor', 'middle')
                .text(d => d.name)
                .style('font-size', '12px')
                .style('fill', d => d.color)
                .style('font-weight', 'bold');
            
            // Обработка событий узлов
            node.on('mouseover', function(event, d) {
                // Подсветка узла при наведении
                d3.select(this)
                    .attr('stroke', '#000')
                    .attr('stroke-width', 2);
                
                // Подсветка связанных узлов и связей
                const connectedLinks = vis.graph.links.filter(l => l.source.id === d.id || l.target.id === d.id);
                const connectedNodeIds = new Set();
                
                connectedLinks.forEach(l => {
                    connectedNodeIds.add(l.source.id);
                    connectedNodeIds.add(l.target.id);
                    
                    d3.select(link.nodes()[vis.graph.links.indexOf(l)])
                        .attr('stroke', '#000')
                        .attr('stroke-width', l => 3 + 5 * l.value)
                        .attr('opacity', 1);
                });
                
                node.filter(n => connectedNodeIds.has(n.id) && n.id !== d.id)
                    .attr('stroke', '#666')
                    .attr('stroke-width', 1.5);
                
                // Показ всплывающей подсказки
                const tooltip = d3.select('#tooltip')
                    .style('opacity', 1)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                
                tooltip.html(`<strong>${d.name}</strong>`);
            })
            .on('mouseout', function() {
                // Возврат к обычному виду при уходе курсора
                d3.select(this)
                    .attr('stroke', null);
                
                link.attr('stroke', '#999')
                    .attr('stroke-width', d => 1 + 5 * d.value)
                    .attr('opacity', d => 0.2 + 0.8 * d.value);
                
                node.attr('stroke', null);
                
                d3.select('#tooltip').style('opacity', 0);
            })
            .on('click', function(event, d) {
                // Показ панели с полным определением
                const panel = d3.select('#definitionPanel');
                
                panel.style('opacity', 1)
                    .html(`
                        <h3>${d.name}</h3>
                        <p>${d.text}</p>
                        <p>
                        <strong>Категория:</strong> ${d.category === 'category' ? 'По категориям' : d.category === 'object' ? 'По объектам' : 'По аудитории'}
                        </p>
                        <h4>Семантические связи:</h4>
                    `);
                
                // Добавление информации о связанных определениях
                const connectedLinks = vis.graph.links.filter(l => l.source.id === d.id || l.target.id === d.id)
                    .sort((a, b) => b.value - a.value);
                
                if (connectedLinks.length > 0) {
                    const relatedList = panel.append('ul')
                        .style('padding-left', '20px');
                    
                    connectedLinks.forEach(link => {
                        const relatedNode = link.source.id === d.id ? link.target : link.source;
                        const similarity = Math.round(link.value * 100);
                        
                        relatedList.append('li')
                            .html(`<strong>${relatedNode.name}</strong> (сходство: ${similarity}%)`);
                    });
                } else {
                    panel.append('p')
                        .text('Нет сильных семантических связей с другими определениями.');
                }
            });
            
            // Обновление позиций элементов при каждом "тике" симуляции
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Функция для перетаскивания узлов
            function drag(simulation) {
                function dragstarted(event) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                }
                
                function dragged(event) {
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                }
                
                function dragended(event) {
                    if (!event.active) simulation.alphaTarget(0);
                    event.subject.fx = null;
                    event.subject.fy = null;
                }
                
                return d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended);
            }
        }
        
        // Функция для наполнения списка определений
        function populateDefinitionsList() {
            const definitionsList = document.getElementById('definitionsList');
            definitionsList.innerHTML = '';
            
            // Сортировка определений по категориям
            const sortedDefinitions = [...definitions].sort((a, b) => {
                if (a.category !== b.category) {
                    return a.category.localeCompare(b.category);
                }
                return a.type.localeCompare(b.type);
            });
            
            // Добавление каждого определения в список
            sortedDefinitions.forEach(def => {
                const li = document.createElement('li');
                
                // Добавление типа и категории
                const categoryClass = `category-${def.category}`;
                const categoryText = def.category === 'category' ? 'По категориям' : 
                                    def.category === 'object' ? 'По объектам' : 'По аудитории';
                
                li.innerHTML = `
                    <span class="definition-type">${def.type}</span>
                    <span class="definition-category ${categoryClass}">${categoryText}</span>
                    <p>${def.text}</p>
                `;
                
                definitionsList.appendChild(li);
            });
        }
        
        // Обработка переключения вкладок в модальном окне с информацией
        function setupTabsHandling() {
            document.querySelectorAll('.tab-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    
                    // Обновление активной кнопки
                    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Обновление активного содержимого
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    document.getElementById(tabId).classList.add('active');
                });
            });
        }
        
        // Функция для переключения темы
        function toggleTheme() {
            const html = document.documentElement;
            const themeToggle = document.getElementById('themeToggle');
            
            if (html.getAttribute('data-theme') === 'dark') {
                html.removeAttribute('data-theme');
                themeToggle.textContent = '🌙';
                localStorage.setItem('theme', 'light');
            } else {
                html.setAttribute('data-theme', 'dark');
                themeToggle.textContent = '☀️';
                localStorage.setItem('theme', 'dark');
            }
        }
        
        // Установка сохраненной темы при загрузке
        function setThemeFromStorage() {
            const savedTheme = localStorage.getItem('theme');
            const themeToggle = document.getElementById('themeToggle');
            
            if (savedTheme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeToggle.textContent = '☀️';
            } else {
                document.documentElement.removeAttribute('data-theme');
                themeToggle.textContent = '🌙';
            }
        }
        
        // Инициализация и обработка переключения видов
        document.addEventListener('DOMContentLoaded', function() {
            const vis = initVisualization();
            
            // Установка темы из локального хранилища
            setThemeFromStorage();
            
            // Обработчик для переключения темы
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            
            // Обработчики для кнопок переключения вида
            document.querySelectorAll('.control-btn[data-view]').forEach(button => {
                button.addEventListener('click', function() {
                    // Обновление активной кнопки
                    document.querySelectorAll('.control-btn[data-view]').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    const viewType = this.getAttribute('data-view');
                    
                    // Переключение вида визуализации
                    if (viewType === 'force') {
                        // Очищаем и инициализируем заново силовой граф
                        vis.svg.remove();
                        const newVis = initVisualization();
                        Object.assign(vis, newVis);
                    } else if (viewType === 'cluster') {
                        showClusterView(vis);
                    } else if (viewType === 'radial') {
                        showRadialView(vis);
                    }
                });
            });
            
            // Настройка модальных окон
            const definitionsModal = document.getElementById('definitionsModal');
            const infoModal = document.getElementById('infoModal');
            
            // Открытие модального окна со списком определений
            document.getElementById('definitionsBtn').addEventListener('click', function() {
                populateDefinitionsList();
                definitionsModal.style.display = 'flex';
            });
            
            // Открытие модального окна с информацией
            document.getElementById('infoBtn').addEventListener('click', function() {
                infoModal.style.display = 'flex';
            });
            
            // Закрытие модальных окон
            document.getElementById('closeDefinitionsModal').addEventListener('click', function() {
                definitionsModal.style.display = 'none';
            });
            
            document.getElementById('closeInfoModal').addEventListener('click', function() {
                infoModal.style.display = 'none';
            });
            
            // Закрытие модальных окон при клике вне содержимого
            window.addEventListener('click', function(event) {
                if (event.target === definitionsModal) {
                    definitionsModal.style.display = 'none';
                }
                if (event.target === infoModal) {
                    infoModal.style.display = 'none';
                }
            });
            
            // Настройка вкладок в информационном модальном окне
            setupTabsHandling();
            
            // Адаптивность для мобильных устройств
            function handleResize() {
                if (window.innerWidth <= 768) {
                    document.getElementById('definitionPanel').style.position = 'static';
                    document.getElementById('definitionPanel').style.opacity = '1';
                } else {
                    document.getElementById('definitionPanel').style.position = 'absolute';
                    document.getElementById('definitionPanel').style.opacity = '0';
                }
            }
            
            window.addEventListener('resize', handleResize);
            handleResize();
        });
    </script>
</body>
</html>