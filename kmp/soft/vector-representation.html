<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Визуализация векторных представлений</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
	<script src="d3.v7.min.js"></script>
    <style>
        :root {
            --bg-color: #f5f5f5;
			--text-color: #333;
            --primary-color: #4a6fa5;
            --secondary-color: #e9ecef;
            --accent-color: #6c5ce7;
            --card-bg: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.1);
			--primary-color: #3e76ad;
		--header-text-color: #ffffff;
		--border-radius: 8px;
        }

        .dark-theme {
            --bg-color: #1a1a2e;
			--text-color: #e6e6e6;
            --primary-color: #5a7bb5;
            --secondary-color: #2d3748;
            --accent-color: #8c7ae6;
            --card-bg: #2a2a40;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
        }

        header {
            background-color: var(--primary-color);
			color: var(--header-text-color);
			display: flex;
            justify-content: space-between;
            align-items: center;
			padding: 30px 20px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            margin-bottom: 30px;
            padding-bottom: 30px;
            border-bottom: 1px solid var(--border);
			background-image: linear-gradient(135deg, var(--primary-color) 0%, #2c3e50 100%);
        }

        h1 {
            color: #ffffff;
            font-size: 1.8rem;
        }

        .theme-toggle {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px var(--shadow-color);
        }

        h2 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        p {
            margin-bottom: 15px;
        }

        .visualization-container {
            width: 100%;
            height: 500px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            background-color: var(--secondary-color);
        }

        svg {
            width: 100%;
            height: 100%;
        }

        .tooltip {
            position: absolute;
            padding: 12px;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            max-width: 240px;
            z-index: 100;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: translate(-50%, -100%) translateY(-10px);
        }

        .tooltip:after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid var(--card-bg);
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }

        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--secondary-color);
            border-radius: 5px;
            background-color: var(--card-bg);
            color: var(--text-color);
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--accent-color);
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            margin-right: 8px;
        }

        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--secondary-color);
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--accent-color);
        }

        .tab.active {
            border-bottom: 2px solid var(--accent-color);
            color: var(--accent-color);
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid var(--secondary-color);
            font-size: 0.9rem;
            color: var(--text-color);
        }

        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .visualization-container {
                height: 350px;
            }

            .tabs {
                flex-direction: column;
            }

            .tab {
                padding: 8px 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Визуализация векторных представлений</h1>
            <button class="theme-toggle" id="themeToggle">☀️</button>
        </header>

        <div class="card">
            <div class="tabs">
                <div class="tab active" data-tab="vector-viz">Векторные представления</div>
                <div class="tab" data-tab="semantic-space">Семантическое пространство</div>
                <div class="tab" data-tab="about">О приложении</div>
            </div>

            <div class="tab-content active" id="vector-viz">
                <h2>Визуализация векторных представлений</h2>
                <p>Наведите курсор на элементы для детальной информации о структуре основных типов векторных представлений.</p>
                
                <div class="visualization-container">
                    <svg id="vectorViz"></svg>
                    <div class="tooltip" id="tooltip"></div>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <span>Векторные представления разных типов:</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #6c5ce7;"></div>
                        <span>Word Embeddings</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e84393;"></div>
                        <span>Contextual Embeddings</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #00b894;"></div>
                        <span>Sentence Embeddings</span>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="semantic-space">
                <h2>Персонализированное семантическое пространство</h2>
                <p>Введите свою Фамилию, и система создаст уникальное семантическое пространство вашей идентификации (в качестве изучающего компьютерную лингвистку студента, конечно) на основе связей между ключевыми концептами предметного поля учебного курса.</p>
                
                <div class="form-group">
                    <label for="lastName">Ваша фамилия:</label>
                    <input type="text" id="lastName" placeholder="Например: Иванова">
                </div>
                <button id="generateBtn">Создать пространство</button>
                
                <div class="visualization-container">
                    <svg id="semanticViz"></svg>
                    <div class="tooltip" id="semanticTooltip"></div>
                </div>
            </div>

            <div class="tab-content" id="about">
                <h2>О приложении</h2>
                <p>Приложение для визуализации векторных представлений в NLP, CL, AI</p>
                <h3>Основные возможности:</h3>
                <ul style="padding-left: 20px;">
                    <li>Интерактивная радиальная диаграмма иерархии эмбеддингов</li>
                    <li>Персонализированное семантическое пространство</li>
                    <li>Адаптивный дизайн для всех устройств</li>
                    <li>Плавные переходы и анимации</li>
                </ul><br>
                <h3>Использованные технологии:</h3>
                <ul style="padding-left: 20px;">
                    <li>HTML</li>
                    <li>CSS</li>
                    <li>JavaScript</li>
                    <li>D3.v7.mini.js</li>
                </ul>
                
              </div>
        </div>

        <footer class="footer">
<div class="container">
<p>© 2025 | kmp | CC BY-NC-SA 4.0<br>
Разработано для студентов БрГУ имени А.С. Пушкина</p>
</div>
</footer>
<div style="position: fixed; bottom: 10px; right: 33px; opacity: 0.3; font-size: 14px;">kmp+</div>
    
    </div>

    <script>
        // Переключение темы
        const themeToggle = document.getElementById('themeToggle');
        themeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark-theme');
            themeToggle.textContent = document.body.classList.contains('dark-theme') ? '🌙' : '☀️';
            // Перерисовываем визуализации при смене темы
            if (document.getElementById('vector-viz').classList.contains('active')) {
                createSunburstVisualization();
            } else if (document.getElementById('semantic-space').classList.contains('active')) {
                const lastName = document.getElementById('lastName').value.trim();
                if (lastName) createNetworkVisualization(lastName);
            }
        });

        // Переключение вкладок
        const tabs = document.querySelectorAll('.tab');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
                
                // Инициализация соответствующей визуализации
                if (tabId === 'vector-viz') {
                    createSunburstVisualization();
                } else if (tabId === 'semantic-space') {
                    const lastName = document.getElementById('lastName').value.trim();
                    if (lastName) createNetworkVisualization(lastName);
                }
            });
        });

        // Современная радиальная диаграмма (Sunburst)
        function createSunburstVisualization() {
            const svg = d3.select('#vectorViz');
            const width = svg.node().getBoundingClientRect().width;
            const height = svg.node().getBoundingClientRect().height;
            const radius = Math.min(width, height) / 2 - 20;
            const tooltip = d3.select('#tooltip');
            
            svg.selectAll('*').remove();
            
            // Создаем группу для диаграммы
            const g = svg.append('g')
                .attr('transform', `translate(${width/2},${height/2})`);
            
            // Данные
            const data = {
                name: "Векторные представления",
                description: "Числовые представления текста в многомерном пространстве",
                color: "#4a6fa5",
                children: [
                    {
                        name: "Word Embeddings",
                        description: "Статические представления слов",
                        color: "#6c5ce7",
                        children: [
                            { name: "Word2Vec", description: "CBOW и Skip-gram архитектуры", value: 10, color: "#a55eea" },
                            { name: "GloVe", description: "На основе матрицы совместной встречаемости", value: 8, color: "#8854d0" },
                            { name: "FastText", description: "С учетом субсловной информации", value: 7, color: "#786fa6" }
                        ]
                    },
                    {
                        name: "Contextual Embeddings",
                        description: "Динамические представления с учетом контекста",
                        color: "#e84393",
                        children: [
                            { name: "BERT", description: "Двунаправленный трансформер", value: 12, color: "#fd79a8" },
                            { name: "ELMo", description: "На основе LSTM", value: 6, color: "#e66767" },
                            { name: "GPT", description: "Авторегрессионная модель", value: 9, color: "#cf6a87" }
                        ]
                    },
                    {
                        name: "Sentence Embeddings",
                        description: "Представления целых предложений",
                        color: "#00b894",
                        children: [
                            { name: "USE", description: "Universal Sentence Encoder", value: 7, color: "#55efc4" },
                            { name: "InferSent", description: "Обучен на задаче вывода", value: 5, color: "#00cec9" }
                        ]
                    }
                ]
            };

            // Создаем иерархию
            const root = d3.hierarchy(data)
                .sum(d => d.value || 10)
                .sort((a, b) => b.value - a.value);

            // Создаем макет sunburst
            const partition = d3.partition()
                .size([2 * Math.PI, radius]);
            
            const arc = d3.arc()
                .startAngle(d => d.x0)
                .endAngle(d => d.x1)
                .innerRadius(d => d.y0)
                .outerRadius(d => d.y1 - (d.depth === 0 ? 0 : 1));
            
            // Применяем макет
            partition(root);
            
            // Рисуем сегменты
            g.selectAll('path')
                .data(root.descendants().filter(d => d.depth))
                .enter()
                .append('path')
                .attr('d', arc)
                .style('fill', d => d.data.color)
                .style('fill-opacity', d => 1 - d.depth * 0.15)
                .style('stroke', 'var(--card-bg)')
                .style('stroke-width', 1)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    d3.select(this)
                        .style('stroke-width', 2)
                        .style('filter', 'url(#glow)');
                    
                    // Позиционирование подсказки
                    const [x, y] = d3.pointer(event, svg.node());
                    const tooltipWidth = 240;
                    const tooltipHeight = 100;
                    
                    let left = x;
                    let top = y - tooltipHeight - 20;
                    
                    // Корректировка положения у границ
                    if (left < tooltipWidth / 2) left = tooltipWidth / 2;
                    if (left > width - tooltipWidth / 2) left = width - tooltipWidth / 2;
                    if (top < 20) top = y + 20;
                    
                    tooltip
                        .style('opacity', 1)
                        .style('left', `${left}px`)
                        .style('top', `${top}px`)
                        .style('transform', `translateX(-50%)`)
                        .html(`<strong>${d.data.name}</strong><br>${d.data.description}`);
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .style('stroke-width', 1)
                        .style('filter', 'none');
                    tooltip.style('opacity', 0);
                });
            
            // Добавляем фильтр для свечения
            const defs = svg.append('defs');
            defs.append('filter')
                .attr('id', 'glow')
                .append('feGaussianBlur')
                .attr('stdDeviation', '3')
                .attr('result', 'coloredBlur');
            
            // Добавляем текст
            g.selectAll('text')
                .data(root.descendants().filter(d => d.depth && (d.y0 + d.y1) / 2 * (d.x1 - d.x0) > 10))
                .enter()
                .append('text')
                .attr('transform', d => {
                    const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
                    const y = (d.y0 + d.y1) / 2;
                    return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
                })
                .attr('dy', '0.35em')
                .attr('text-anchor', d => (d.x0 + d.x1) / 2 * 180 / Math.PI < 180 ? 'start' : 'end')
                .text(d => d.data.name)
                .style('font-size', '11px')
                .style('fill', 'var(--text-color)')
                .style('pointer-events', 'none');
        }

        // Визуализация семантического пространства (граф)
        function createNetworkVisualization(lastName) {
            const svg = d3.select('#semanticViz');
            const width = svg.node().getBoundingClientRect().width;
            const height = svg.node().getBoundingClientRect().height;
            const tooltip = d3.select('#semanticTooltip');
            
            svg.selectAll('*').remove();
            
            // Предзаданный набор слов
            const baseWords = [
                "студент", "учеба", "знания", "лингвистика", "языки", 
                "эмбеддинг", "векторы", "семантика", "анализ", "исследование",
                "перевод", "коммуникация", "грамматика", "лексика", "понимание",
                "модель", "алгоритм", "контекст", "представление", "обучение"
            ];
            
            // Генерируем данные
            const nodes = baseWords.map(word => {
                const hash = Array.from(word + lastName).reduce((acc, char) => acc + char.charCodeAt(0), 0);
                const x = (hash % 100) / 100;
                const y = ((hash * 13) % 100) / 100;
                const similarity = calculateSimilarity(word, lastName);
                
                return {
                    id: word,
                    word: word,
                    x: x * (width - 120) + 60,
                    y: y * (height - 120) + 60,
                    value: 18 + similarity * 12,
                    similarity: similarity,
                    color: d3.interpolateCool(similarity * 3.8)
                };
            });
            
            // Добавляем фамилию в центр
            nodes.push({
                id: lastName,
                word: lastName,
                x: width / 2,
                y: height / 2,
                value: 45,
                similarity: 1,
                color: '#f7e139',
                fixed: true
            });
            
            // Создаем связи
            const links = nodes
                .filter(d => !d.fixed)
                .map(d => ({
                    source: d.id,
                    target: lastName,
                    value: d.similarity
                }));
            
            // Симуляция графа
            const simulation = d3.forceSimulation(nodes)
                .force('charge', d3.forceManyBody().strength(-500))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(d => 100 + (1 - d.value) * 150))
                .force('collision', d3.forceCollide().radius(d => d.value * 1.2));
            
            // Рисуем связи
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .enter()
                .append('line')
                .attr('stroke', d => d3.interpolateCool(d.value * 0.8))
                .attr('stroke-width', d => d.value * 2)
                .attr('stroke-opacity', 0.6);
            
            // Рисуем узлы
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter()
                .append('circle')
                .attr('r', d => d.value)
                .attr('fill', d => d.color)
                .attr('stroke', 'var(--card-bg)')
                .attr('stroke-width', 2)
                .style('cursor', 'pointer')
                .call(drag(simulation))
                .on('mouseover', function(event, d) {
                    d3.select(this)
                        .attr('stroke-width', 3)
                        .style('filter', 'url(#glow)');
                    
                    // Позиционирование подсказки
                    const [x, y] = d3.pointer(event, svg.node());
                    const tooltipWidth = 180;
                    const tooltipHeight = 70;
                    
                    let left = x;
                    let top = y - tooltipHeight - 15;
                    
                    if (top < 20) top = y + 15;
                    
                    tooltip
                        .style('opacity', 1)
                        .style('left', `${left}px`)
                        .style('top', `${top}px`)
                        .style('transform', `translateX(-50%)`)
                        .html(`<strong>${d.word}</strong><br>Сходство: ${(d.similarity * 100).toFixed(1)}%`);
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .attr('stroke-width', 2)
                        .style('filter', 'none');
                    tooltip.style('opacity', 0);
                });
            
            // Добавляем текст
            const text = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .enter()
                .append('text')
                .attr('dy', 4)
                .style('font-size', d => Math.min(d.value / 2, 12))
                .style('font-weight', d => d.fixed ? 'bold' : 'normal')
                .text(d => d.word.length > 12 ? d.word.substring(0, 10) + '...' : d.word)
                .style('pointer-events', 'none');
            
            // Обновляем позиции при симуляции
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                text
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Добавляем фильтр для свечения
            const defs = svg.append('defs');
            defs.append('filter')
                .attr('id', 'glow')
                .append('feGaussianBlur')
                .attr('stdDeviation', '3')
                .attr('result', 'coloredBlur');
            
            // Функция для расчета сходства
            function calculateSimilarity(word, lastName) {
                const commonLetters = new Set([...word].filter(char => lastName.includes(char))).size;
                const lengthFactor = 1 - Math.abs(word.length - lastName.length) / 20;
                const randomFactor = (word.length * lastName.length) % 10 / 15;
                
                return Math.min((commonLetters / word.length * 0.6 + randomFactor * 0.2 + lengthFactor * 0.2) * 0.9 + 0.1, 1);
            }
            
            // Функция для перетаскивания узлов
            function drag(simulation) {
                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                
                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    if (!d.fixed) {
                        d.fx = null;
                        d.fy = null;
                    }
                }
                
                return d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended);
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            createSunburstVisualization();
            
            document.getElementById('generateBtn').addEventListener('click', () => {
                const lastName = document.getElementById('lastName').value.trim();
                if (lastName) {
                    createNetworkVisualization(lastName);
                } else {
                    alert('Пожалуйста, введите фамилию');
                }
            });
            
            window.addEventListener('resize', () => {
                if (document.getElementById('vector-viz').classList.contains('active')) {
                    createSunburstVisualization();
                }
                
                const lastName = document.getElementById('lastName').value.trim();
                if (lastName && document.getElementById('semantic-space').classList.contains('active')) {
                    createNetworkVisualization(lastName);
                }
            });
        });
    </script>
</body>
</html>