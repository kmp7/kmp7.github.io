<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kmp+</title>
    <style>
        :root {
            --bg-color: #f5f5f5;
            --text-color: #333;
            --container-bg: white;
            --header-bg: #325980;
            --header-text: white;
            --border-color: #eee;
            --term-color: #325980;
            --equivalent-color: #666;
            --search-border: #ddd;
            --badge-bg: #e8f4fc;
            --badge-color: #3498db;
            --active-btn-bg: #3498db;
            --active-btn-text: white;
            --btn-bg: #f5f5f5;
            --btn-text: #333;
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        .dark-mode {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --container-bg: #2d2d2d;
            --header-bg: #1a3a5a;
            --header-text: #f0f0f0;
            --border-color: #444;
            --term-color: #4a90e2;
            --equivalent-color: #aaa;
            --search-border: #555;
            --badge-bg: #2a4365;
            --badge-color: #63b3ed;
            --active-btn-bg: #63b3ed;
            --active-btn-text: #111;
            --btn-bg: #3d3d3d;
            --btn-text: #ddd;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: var(--container-bg);
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--shadow-color);
            overflow: hidden;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        
        .header {
            background-color: var(--header-bg);
            color: var(--header-text);
            padding: 20px 40px;
            text-align: center;
            position: relative;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .header h1 {
            margin: 0;
            font-size: 24px;
        }
        
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: var(--header-text);
            font-size: 20px;
            cursor: pointer;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.3s;
        }
        
        .theme-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .content {
            padding: 20px;
        }
        
        .search-container {
            margin-bottom: 20px;
        }
        
        .search-box {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--search-border);
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 16px;
            background-color: var(--container-bg);
            color: var(--text-color);
            transition: border-color 0.3s, background-color 0.3s, color 0.3s;
        }
        
        .search-box:focus {
            outline: none;
            border-color: var(--active-btn-bg);
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .language-toggle {
            display: flex;
            justify-content: center;
            flex-grow: 1;
        }
        
        .language-btn {
            background-color: var(--btn-bg);
            color: var(--btn-text);
            border: 1px solid var(--search-border);
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .language-btn:first-child {
            border-radius: 4px 0 0 4px;
        }
        
        .language-btn:last-child {
            border-radius: 0 4px 4px 0;
        }
        
        .language-btn.active {
            background-color: var(--active-btn-bg);
            color: var(--active-btn-text);
            border-color: var(--active-btn-bg);
        }
        
        .glossary-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        
        .glossary-item {
            border-bottom: 1px solid var(--border-color);
            padding: 15px 0;
            transition: border-color 0.3s;
        }
        
        .glossary-item:last-child {
            border-bottom: none;
        }
        
        .term {
            font-weight: bold;
            color: var(--term-color);
            font-size: 18px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: color 0.3s;
        }
        
        .term-text {
            flex: 1;
        }
        
        .equivalent {
            color: var(--equivalent-color);
            font-style: italic;
            font-size: 14px;
            transition: color 0.3s;
        }
        
        .definition {
            margin-top: 5px;
            line-height: 1.5;
        }
        
        .no-results {
            text-align: center;
            padding: 20px;
            color: var(--equivalent-color);
        }
        
        .category-badge {
            background-color: var(--badge-bg);
            color: var(--badge-color);
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 12px;
            margin-left: 10px;
            font-weight: normal;
            transition: background-color 0.3s, color 0.3s;
        }
        
        /* Кнопка добавления новой статьи */
        .add-article-btn {
            background-color: var(--active-btn-bg);
            color: var(--active-btn-text);
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .add-article-btn:hover {
            background-color: var(--term-color);
        }
        
        /* Стили для модального окна */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: var(--container-bg);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
            position: relative;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .modal-title {
            font-size: 20px;
            font-weight: bold;
            color: var(--term-color);
            margin: 0;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-color);
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.3s;
        }
        
        .close-btn:hover {
            background-color: var(--btn-bg);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--text-color);
        }
        
        .form-input, .form-textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--search-border);
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 14px;
            background-color: var(--container-bg);
            color: var(--text-color);
            transition: border-color 0.3s;
        }
        
        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .form-input:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--active-btn-bg);
        }
        
        .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .btn-primary {
            background-color: var(--active-btn-bg);
            color: var(--active-btn-text);
        }
        
        .btn-primary:hover {
            background-color: var(--term-color);
        }
        
        .btn-secondary {
            background-color: var(--btn-bg);
            color: var(--btn-text);
        }
        
        .btn-secondary:hover {
            background-color: var(--search-border);
        }
        
        .lang-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .lang-tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .lang-tab.active {
            border-bottom-color: var(--active-btn-bg);
            color: var(--active-btn-bg);
            font-weight: bold;
        }
        
        .lang-content {
            display: none;
        }
        
        .lang-content.active {
            display: block;
        }
        
        .user-article-badge {
            background-color: #e8f7e8;
            color: #27ae60;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
            font-weight: normal;
        }
        
        .dark-mode .user-article-badge {
            background-color: #1e3a28;
            color: #58d68d;
        }
        
        @media (max-width: 600px) {
            .header {
                padding: 20px 20px 20px 50px;
            }
            
            .theme-toggle {
                top: 50%;
                transform: translateY(-50%);
                right: auto;
                left: 15px;
            }
            
            .term {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .category-badge {
                margin-left: 0;
                margin-top: 5px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .language-toggle {
                width: 100%;
            }
            
            .modal-content {
                width: 95%;
                padding: 15px;
            }
            
            .form-actions {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }
        
        footer {
            text-align: center;
            padding: 20px 0;
            margin-top: 40px;
            font-size: 0.7rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="theme-toggle" id="themeToggle">🌙</button>
            <h1>ТРАНСФОРМЕР</h1>
        </div>
        <div class="content">
            <div class="search-container">
                <input type="text" class="search-box" id="searchInput" placeholder="Поиск ...">
            </div>
            
            <div class="controls">
                <button class="add-article-btn" id="addArticleBtn">
                    <span>+</span> Добавить статью
                </button>
                <div class="language-toggle">
                    <button class="language-btn active" data-lang="ru">Русский</button>
                    <button class="language-btn" data-lang="en">English</button>
                </div>
            </div>
            
            <ul class="glossary-list" id="glossaryList">
                <!-- Content will be dynamically populated here -->
            </ul>
            
            <div class="no-results" id="noResults" style="display:none;">
                Термины не найдены. Попробуйте изменить поисковый запрос.
            </div>
        </div>
    </div>

    <!-- Модальное окно для добавления статьи -->
    <div class="modal" id="articleModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Добавить новую статью</h2>
                <button class="close-btn" id="closeModal">&times;</button>
            </div>
            
            <div class="lang-tabs">
                <div class="lang-tab active" data-lang="ru">Русский</div>
                <div class="lang-tab" data-lang="en">English</div>
            </div>
            
            <form id="articleForm">
                <div class="lang-content active" id="ru-content">
                    <div class="form-group">
                        <label class="form-label" for="ru-term">Термин (русский)</label>
                        <input type="text" class="form-input" id="ru-term" required onpaste="return false;">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="ru-equivalent">Эквивалент (английский)</label>
                        <input type="text" class="form-input" id="ru-equivalent" required onpaste="return false;">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="ru-definition">Определение (русский)</label>
                        <textarea class="form-textarea" id="ru-definition" required onpaste="return false;"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="ru-category">Фамилия Имя</label>
                        <input type="text" class="form-input" id="ru-category" required onpaste="return false;">
                    </div>
                </div>
                
                <div class="lang-content" id="en-content">
                    <div class="form-group">
                        <label class="form-label" for="en-term">Term (English)</label>
                        <input type="text" class="form-input" id="en-term" required onpaste="return false;">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="en-equivalent">Equivalent (Russian)</label>
                        <input type="text" class="form-input" id="en-equivalent" required onpaste="return false;">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="en-definition">Definition (English)</label>
                        <textarea class="form-textarea" id="en-definition" required onpaste="return false;"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="en-category">Last Name First Name</label>
                        <input type="text" class="form-input" id="en-category" required onpaste="return false;">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" id="cancelBtn">Отмена</button>
                    <button type="submit" class="btn btn-primary">Добавить статью</button>
                </div>
            </form>
        </div>
    </div>
<footer class="footer">
<div class="container">
<p>© 2025 | kmp | CC BY-NC-SA 4.0</p>
<p>Разработано для студентов БрГУ имени А.С. Пушкина</p>
</div>
</footer>
<div style="position: fixed; bottom: 10px; color: #777777; right: 30px; opacity: 0.3; font-size: 14px;">kmp+</div>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Glossary data
            let glossaryData = [
  {
    "ru": {
      "term": "Трансформер (академическое определение)",
      "equivalent": "Transformer (academic definition)",
      "definition": "Архитектура глубокой нейронной сети, основанная на механизме самовнимания (self-attention), которая радикально отошла от предшествующих парадигм последовательной обработки, присущих рекуррентным (RNN) и сверточным (CNN) сетям. Её ключевая инновация — возможность параллельного вычисления взвешенных зависимостей между всеми элементами входной последовательности независимо от их позиционного расстояния, что эффективно решает проблему исчезающего градиента и позволяет модели улавливать сложные дальнодействующие контекстные связи. Архитектурно Трансформер состоит из энкодера и декодера, каждый из которых включает в себя многослойные блоки самовнимания и позиционные кодировки для учета порядка элементов.",
      "category": "Академическое определение, синтез современной литературы"
    },
    "en": {
      "term": "Transformer (academic definition)",
      "equivalent": "Трансформер (академическое определение)",
      "definition": "A deep neural network architecture based on the self-attention mechanism that radically departed from previous sequential processing paradigms inherent in recurrent (RNN) and convolutional (CNN) networks. Its key innovation is the ability to compute weighted dependencies between all elements of the input sequence in parallel, regardless of their positional distance, which effectively solves the vanishing gradient problem and allows the model to capture complex long-range contextual connections. Architecturally, the Transformer consists of an encoder and decoder, each comprising multi-layer self-attention blocks and positional encodings to account for element order.",
      "category": "Academic definition, synthesis of contemporary literature"
    }
  },
  {
    "ru": {
      "term": "Трансформер",
      "equivalent": "Transformer",
      "definition": "Архитектура нейронной сети, представленная в 2017 году, которая использует исключительно механизмы внимания для обработки последовательностей данных. Состоит из энкодера и декодера с много-головым самовниманием и позиционными кодировками.",
      "category": "Базовая архитектура, 2017, Attention Is All You Need"
    },
    "en": {
      "term": "Transformer",
      "equivalent": "Трансформер",
      "definition": "A neural network architecture introduced in 2017 that uses exclusively attention mechanisms for processing data sequences. Consists of an encoder and decoder with multi-head self-attention and positional encodings.",
      "category": "Basic Architecture, 2017, Attention Is All You Need"
    }
  },
  {
    "ru": {
      "term": "Трансформер-энкодер",
      "equivalent": "Transformer Encoder",
      "definition": "Часть архитектуры Трансформера, предназначенная для обработки и представления входных данных. Состоит из идентичных слоев, каждый из которых содержит механизм самовнимания и полносвязную feed-forward сеть с остаточными соединениями и нормализацией.",
      "category": "Кодирующая архитектура, 2017, BERT, RoBERTa"
    },
    "en": {
      "term": "Transformer Encoder",
      "equivalent": "Трансформер-энкодер",
      "definition": "The part of the Transformer architecture designed for processing and representing input data. Consists of identical layers, each containing a self-attention mechanism and a fully connected feed-forward network with residual connections and normalization.",
      "category": "Encoding Architecture, 2017, BERT, RoBERTa"
    }
  },
  {
    "ru": {
      "term": "Трансформер-декодер",
      "equivalent": "Transformer Decoder",
      "definition": "Часть архитектуры Трансформера, генерирующая выходную последовательность. Включает маскированное самовнимание (для предотвращения утечки будущей информации), перекрёстное внимание к выходу энкодера и полносвязные слои. Используется в задачах генерации.",
      "category": "Генерирующая архитектура, 2017, GPT, ChatGPT"
    },
    "en": {
      "term": "Transformer Decoder",
      "equivalent": "Трансформер-декодер",
      "definition": "The part of the Transformer architecture that generates the output sequence. Includes masked self-attention (to prevent future information leakage), cross-attention to encoder output, and fully connected layers. Used in generation tasks.",
      "category": "Generative Architecture, 2017, GPT, ChatGPT"
    }
  },
  {
    "ru": {
      "term": "Большая языковая модель (LLM) на Трансформерах",
      "equivalent": "Large Language Model (Transformer-based)",
      "definition": "Масштабная нейронная сеть архитектуры Трансформер, предобученная на огромных корпусах текстовых данных. Способна решать широкий спектр задач: генерация текста, перевод, вопросно-ответные системы, суммаризация через механизм контекстного обучения (in-context learning).",
      "category": "Масштабированная модель, 2018+, GPT, PaLM, LLaMA"
    },
    "en": {
      "term": "Large Language Model (Transformer-based)",
      "equivalent": "Большая языковая модель (LLM) на Трансформерах",
      "definition": "A large-scale neural network of Transformer architecture, pre-trained on massive text corpora. Capable of solving a wide range of tasks: text generation, translation, question-answering, summarization through in-context learning mechanism.",
      "category": "Scaled Model, 2018+, GPT, PaLM, LLaMA"
    }
  },
  {
    "ru": {
      "term": "Механизм внимания (Attention)",
      "equivalent": "Attention Mechanism",
      "definition": "Вычислительный механизм, позволяющий модели динамически взвешивать важность различных частей входных данных при обработке каждого элемента. В Трансформере реализован как скалярное произведение запросов, ключей и значений (Scaled Dot-Product Attention).",
      "category": "Базовый механизм, 2015-2017, Neural Machine Translation"
    },
    "en": {
      "term": "Attention Mechanism",
      "equivalent": "Механизм внимания (Attention)",
      "definition": "A computational mechanism that allows the model to dynamically weigh the importance of different parts of the input data when processing each element. In Transformer implemented as Scaled Dot-Product Attention of queries, keys and values.",
      "category": "Basic Mechanism, 2015-2017, Neural Machine Translation"
    }
  },
  {
    "ru": {
      "term": "Много-головое внимание (Multi-Head Attention)",
      "equivalent": "Multi-Head Attention",
      "definition": "Усовершенствование механизма внимания, при котором самовнимание вычисляется параллельно в нескольких различных проекционных пространствах ('головах'), что позволяет модели совместно обрабатывать информацию из разных подпространств представлений.",
      "category": "Параллельное внимание, 2017, Multi-Head Self-Attention"
    },
    "en": {
      "term": "Multi-Head Attention",
      "equivalent": "Много-головое внимание (Multi-Head Attention)",
      "definition": "An enhancement of the attention mechanism where self-attention is computed in parallel in several different projection spaces ('heads'), allowing the model to jointly process information from different representation subspaces.",
      "category": "Parallel Attention, 2017, Multi-Head Self-Attention"
    }
  },
  {
    "ru": {
      "term": "Позиционные кодировки (Positional Encoding)",
      "equivalent": "Positional Encoding",
      "definition": "Векторное представление, добавляемое к входным эмбеддингам для передачи информации о порядке элементов в последовательности. В оригинальном Трансформере используются синусоидальные функции разной частоты.",
      "category": "Позиционная информация, 2017, Sinusoidal Positional Encoding"
    },
    "en": {
      "term": "Positional Encoding",
      "equivalent": "Позиционные кодировки (Positional Encoding)",
      "definition": "Vector representation added to input embeddings to convey information about the order of elements in a sequence. In the original Transformer, sinusoidal functions of different frequencies are used.",
      "category": "Positional Information, 2017, Sinusoidal Positional Encoding"
    }
  },
  {
    "ru": {
      "term": "Трансформер для компьютерного зрения (Vision Transformer)",
      "equivalent": "Vision Transformer (ViT)",
      "definition": "Адаптация архитектуры Трансформер для задач компьютерного зрения, где изображение разбивается на последовательность патчей, которые обрабатываются как токены в NLP. Показал state-of-the-art результаты в классификации изображений.",
      "category": "Кросс-доменное применение, 2020, Vision Transformer"
    },
    "en": {
      "term": "Vision Transformer (ViT)",
      "equivalent": "Трансформер для компьютерного зрения (Vision Transformer)",
      "definition": "Adaptation of Transformer architecture for computer vision tasks, where an image is split into a sequence of patches processed as tokens in NLP. Achieved state-of-the-art results in image classification.",
      "category": "Cross-Domain Application, 2020, Vision Transformer"
    }
  },
  {
    "ru": {
      "term": "Разреженный Трансформер (Sparse Transformer)",
      "equivalent": "Sparse Transformer",
      "definition": "Модификация Трансформера с разреженными механизмами внимания, уменьшающая вычислительную сложность с O(n²) до O(n√n) или O(n log n). Позволяет обрабатывать значительно более длинные последовательности.",
      "category": "Эффективность вычислений, 2019+, Longformer, BigBird"
    },
    "en": {
      "term": "Sparse Transformer",
      "equivalent": "Разреженный Трансформер (Sparse Transformer)",
      "definition": "A modification of Transformer with sparse attention mechanisms that reduces computational complexity from O(n²) to O(n√n) or O(n log n). Enables processing of significantly longer sequences.",
      "category": "Computational Efficiency, 2019+, Longformer, BigBird"
    }
  },
  {
    "ru": {
      "term": "Трансформер с кэшированием ключей-значений (KV-Caching)",
      "equivalent": "Transformer with KV-Caching",
      "definition": "Оптимизация для ускорения инференса в декодере Трансформера, при которой ключи и значения предыдущих токенов кэшируются и переиспользуются при генерации последующих токенов, что значительно снижает вычислительные затраты.",
      "category": "Оптимизация инференса, 2020+, LLM Inference Optimization"
    },
    "en": {
      "term": "Transformer with KV-Caching",
      "equivalent": "Трансформер с кэшированием ключей-значений (KV-Caching)",
      "definition": "Optimization to accelerate inference in Transformer decoder, where keys and values of previous tokens are cached and reused when generating subsequent tokens, significantly reducing computational costs.",
      "category": "Inference Optimization, 2020+, LLM Inference Optimization"
    }
  },
  {
    "ru": {
      "term": "Трансформер (с позиции передовой LLM)",
      "equivalent": "Transformer (from an advanced LLM perspective)",
      "definition": "Фундаментальная архитектурная парадигма, ставшая основой для современного искусственного интеллекта. Не просто нейросеть, а универсальный вычислительный субстрат для обработки последовательностей любой природы: текста, кода, изображений, звука, белковых структур и мультимодальных данных. С позиции LLM, Трансформер — это высокомасштабируемый, параллельно обучаемый механизм извлечения контекстных паттернов, чья эффективность определяется тремя ключевыми свойствами: способностью моделировать сложные нелокальные зависимости через механизм внимания; архитектурной гомогенностью, позволяющей равномерно масштабировать параметры и данные; и универсальностью, обеспечивающей перенос обучения между доменами. Критически важными для современных LLM стали производные оптимизации: Rotary Positional Embeddings (RoPE) для лучшего учета относительных позиций, Grouped-Query Attention для снижения памяти, архитектуры 'только декодера' для авторегрессионной генерации и механизмы эффективного внимания для обработки длинных контекстов. Трансформер создал не просто модель, а экосистему, где масштабирование параметров (до триллионов), данных (до десятков триллионов токенов) и вычислительных ресурсов привело к emergence-свойствам — качественному скачку в рассуждении, обобщении и решении задач.",
      "category": "LLM для LLM"
    },
    "en": {
      "term": "Transformer (from an advanced LLM perspective)",
      "equivalent": "Трансформер (с позиции передовой LLM)",
      "definition": "A fundamental architectural paradigm that became the foundation of modern artificial intelligence. Not just a neural network, but a universal computational substrate for processing sequences of any nature: text, code, images, sound, protein structures and multimodal data. From an LLM's perspective, the Transformer is a highly scalable, parallel-trainable mechanism for extracting contextual patterns, whose effectiveness is determined by three key properties: the ability to model complex non-local dependencies through attention; architectural homogeneity enabling uniform scaling of parameters and data; and universality facilitating cross-domain transfer learning. Critical for modern LLMs are derivative optimizations: Rotary Positional Embeddings (RoPE) for better relative position awareness, Grouped-Query Attention for memory reduction, decoder-only architectures for autoregressive generation, and efficient attention mechanisms for long-context processing. The Transformer created not just a model, but an ecosystem where scaling of parameters (to trillions), data (to tens of trillions of tokens) and computational resources led to emergence properties — a qualitative leap in reasoning, generalization and problem-solving.",
      "category": "LLM for LLMs"
    }
  }
]

                                  

            // DOM elements
            const searchInput = document.getElementById('searchInput');
            const glossaryList = document.getElementById('glossaryList');
            const noResults = document.getElementById('noResults');
            const languageBtns = document.querySelectorAll('.language-btn');
            const themeToggle = document.getElementById('themeToggle');
            const body = document.body;
            const addArticleBtn = document.getElementById('addArticleBtn');
            const articleModal = document.getElementById('articleModal');
            const closeModal = document.getElementById('closeModal');
            const cancelBtn = document.getElementById('cancelBtn');
            const articleForm = document.getElementById('articleForm');
            const langTabs = document.querySelectorAll('.lang-tab');
            const langContents = document.querySelectorAll('.lang-content');

            // Current language (default: Russian)
            let currentLang = 'ru';

            // Theme state
            let isDarkMode = false;

            // Check for saved theme preference
            if (localStorage.getItem('darkMode') === 'enabled') {
                enableDarkMode();
            }

            // Check for saved user articles
            if (localStorage.getItem('userArticles')) {
                const userArticles = JSON.parse(localStorage.getItem('userArticles'));
                glossaryData = [...glossaryData, ...userArticles];
            }

            // Function to enable dark mode
            function enableDarkMode() {
                body.classList.add('dark-mode');
                themeToggle.textContent = '☀️';
                isDarkMode = true;
                localStorage.setItem('darkMode', 'enabled');
            }

            // Function to disable dark mode
            function disableDarkMode() {
                body.classList.remove('dark-mode');
                themeToggle.textContent = '🌙';
                isDarkMode = false;
                localStorage.setItem('darkMode', 'disabled');
            }

            // Theme toggle event
            themeToggle.addEventListener('click', function() {
                if (isDarkMode) {
                    disableDarkMode();
                } else {
                    enableDarkMode();
                }
            });

            // Function to render glossary items
            function renderGlossary(items, lang) {
                glossaryList.innerHTML = '';
                
                if (items.length === 0) {
                    noResults.style.display = 'block';
                    return;
                }
                
                noResults.style.display = 'none';
                
                items.forEach((item, index) => {
                    const langData = item[lang];
                    const isUserArticle = index >= 15; // Первые 2 элемента - оригинальные
                    
                    const li = document.createElement('li');
                    li.className = 'glossary-item';
                    
                    li.innerHTML = `
                        <div class="term">
                            <span class="term-text">${langData.term}</span>
                            <div>
                                <span class="category-badge">${langData.category}</span>
                                ${isUserArticle ? '<span class="user-article-badge">Пользовательская</span>' : ''}
                            </div>
                        </div>
                        <div class="equivalent">${langData.equivalent}</div>
                        <div class="definition">${langData.definition}</div>
                    `;
                    
                    glossaryList.appendChild(li);
                });
            }

            // Initial render
            renderGlossary(glossaryData, currentLang);

            // Search functionality
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                
                if (searchTerm === '') {
                    renderGlossary(glossaryData, currentLang);
                    return;
                }
                
                const filteredItems = glossaryData.filter(item => {
                    const langData = item[currentLang];
                    return (
                        langData.term.toLowerCase().includes(searchTerm) ||
                        langData.equivalent.toLowerCase().includes(searchTerm) ||
                        langData.definition.toLowerCase().includes(searchTerm) ||
                        langData.category.toLowerCase().includes(searchTerm)
                    );
                });
                
                renderGlossary(filteredItems, currentLang);
            });
            
            // Language toggle
            languageBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    const lang = this.getAttribute('data-lang');
                    
                    // Update active button
                    languageBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update language and re-render
                    currentLang = lang;
                    
                    // Update placeholder text based on language
                    if (lang === 'ru') {
                        searchInput.placeholder = 'Поиск ...';
                        noResults.textContent = 'Термины не найдены. Попробуйте изменить поисковый запрос.';
                        document.querySelector('title').textContent = 'Глоссарий';
                    } else {
                        searchInput.placeholder = 'Search term...';
                        noResults.textContent = 'No terms found. Try changing your search query.';
                        document.querySelector('title').textContent = 'Glossary';
                    }
                    
                    // Re-apply search if there's a search term
                    const searchTerm = searchInput.value.toLowerCase();
                    
                    if (searchTerm === '') {
                        renderGlossary(glossaryData, currentLang);
                    } else {
                        const filteredItems = glossaryData.filter(item => {
                            const langData = item[currentLang];
                            return (
                                langData.term.toLowerCase().includes(searchTerm) ||
                                langData.equivalent.toLowerCase().includes(searchTerm) ||
                                langData.definition.toLowerCase().includes(searchTerm) ||
                                langData.category.toLowerCase().includes(searchTerm)
                            );
                        });
                        
                        renderGlossary(filteredItems, currentLang);
                    }
                });
            });

            // Открытие модального окна
            addArticleBtn.addEventListener('click', function() {
                articleModal.style.display = 'flex';
                document.getElementById('ru-term').focus();
            });

            // Закрытие модального окна
            function closeArticleModal() {
                articleModal.style.display = 'none';
                articleForm.reset();
            }

            closeModal.addEventListener('click', closeArticleModal);
            cancelBtn.addEventListener('click', closeArticleModal);

            // Закрытие модального окна при клике вне его
            window.addEventListener('click', function(event) {
                if (event.target === articleModal) {
                    closeArticleModal();
                }
            });

            // Переключение между вкладками языков в модальном окне
            langTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const lang = this.getAttribute('data-lang');
                    
                    // Обновление активной вкладки
                    langTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Показать соответствующий контент
                    langContents.forEach(content => {
                        content.classList.remove('active');
                        if (content.id === `${lang}-content`) {
                            content.classList.add('active');
                        }
                    });
                });
            });

            // Обработка отправки формы
            articleForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                // Создание новой статьи
                const newArticle = {
                    "ru": {
                        "term": document.getElementById('ru-term').value,
                        "equivalent": document.getElementById('ru-equivalent').value,
                        "definition": document.getElementById('ru-definition').value,
                        "category": document.getElementById('ru-category').value
                    },
                    "en": {
                        "term": document.getElementById('en-term').value,
                        "equivalent": document.getElementById('en-equivalent').value,
                        "definition": document.getElementById('en-definition').value,
                        "category": document.getElementById('en-category').value
                    }
                };
                
                // Добавление статьи в данные
                glossaryData.push(newArticle);
                
                // Сохранение пользовательских статей в localStorage
                const userArticles = glossaryData.slice(2); // Все статьи кроме оригинальных
                localStorage.setItem('userArticles', JSON.stringify(userArticles));
                
                // Перерисовка списка
                renderGlossary(glossaryData, currentLang);
                
                // Закрытие модального окна
                closeArticleModal();
                
                // Показ сообщения об успехе
                alert(currentLang === 'ru' ? 'Статья успешно добавлена!' : 'Article added successfully!');
            });

            // Запрет на вставку в поля ввода
            const inputFields = document.querySelectorAll('input, textarea');
            inputFields.forEach(field => {
                field.addEventListener('paste', function(e) {
                    e.preventDefault();
                    return false;
                });
            });
        });
    </script>
</body>
</html>