<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Простой SVG-редактор</title>
    <style>
        :root {
            --primary-dark: #325980;
            --primary: #3498db;
            --light-gray: #f1f1f1;property-group
            --lighter-gray: #f5f5f5;
            --white: #ffffff;
			--primary-color: #3e76ad;
		--header-text-color: #ffffff;
		--border-radius: 8px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }
        
        body {
            background-color: var(--lighter-gray);
            color: var(--primary-dark);
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 20px;
        }
        
        header {
            background-color: var(--primary-color);
            color: var(--white);
            padding: 25px;
            border-radius: 5px 5px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
			 background-image: linear-gradient(135deg, var(--primary-color) 0%, #2c3e50 100%);
        }
		
		
        
        .main-content {
            display: flex;
            flex: 1;
            gap: 20px;
        }
        
        .toolbar {
            background-color: var(--light-gray);
            padding: 15px;
            border-radius: 5px;
            width: 340px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .tool-group {
            background-color: var(--white);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .tool-group h3 {
            margin-bottom: 10px;
            color: var(--primary-dark);
            font-size: 16px;
        }
        
        .tools {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .tool-btn {
            background-color: var(--white);
            border: 1px solid var(--primary);
            color: var(--primary-dark);
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tool-btn:hover {
            background-color: var(--primary);
            color: var(--white);
        }
        
        .tool-btn.active {
            background-color: var(--primary);
            color: var(--white);
        }
        
        .canvas-container {
            flex: 1;
            background-color: var(--white);
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
        }
        
        #svg-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .property-panel {
            background-color: var(--light-gray);
            padding: 15px;
            border-radius: 5px;
            width: 250px;
        }
        
        .property-group {
            background-color: var(--white);
            padding: 7px;
            border-radius: 5px;
            margin-bottom: 5px;
            border: 1px solid #ddd;
        }
        
        .property-group h3 {
            margin-bottom: 10px;
            color: var(--primary-dark);
            font-size: 16px;
        }
        
        .property {
            margin-bottom: 8px;
        }
        
        .property label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .property input, .property select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;

        }
        
        .color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .color-preview {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: var(--primary-dark);
        }
        
        .action-btn {
            margin-left: 10px;
        }
        
        .export-options {
            display: flex;
            gap: 10px;
        }
        
        /* Модальное окно для экспорта */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: var(--white);
            padding: 20px;
            border-radius: 5px;
            max-width: 500px;
            width: 100%;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .modal-header h2 {
            color: var(--primary-dark);
            margin: 0;
        }
        
        .close-modal {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--primary-dark);
            cursor: pointer;
        }
        
        .export-preview {
            margin: 15px 0;
            text-align: center;
        }
        
        .export-preview canvas {
            max-width: 100%;
            border: 1px solid #ddd;
        }
        
        .export-options {
            margin-top: 15px;
        }
		
		footer {
      text-align: center;
      padding: 20px 0;
      margin-top: 40px;
      font-size: 0.9rem;
      border-top: 0px solid #ddd;
    }
	
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>SVG-редактор</h1>
            <div>
                <button id="export-btn">Экспорт</button>
                <button id="save-btn" class="action-btn">Сохранить SVG</button>
                <button id="clear-btn" class="action-btn">Очистить</button>
            </div>
        </header>
        
        <div class="main-content">
            <div class="toolbar">
                <div class="tool-group">
                    <h3>Инструменты</h3>
                    <div class="tools">
                       <button class="tool-btn active" data-tool="select" title="Выбрать">⚪</button>
                        <button class="tool-btn" data-tool="rect" title="Прямоугольник">□</button>
                        <button class="tool-btn" data-tool="circle" title="Круг">○</button>
                        <button class="tool-btn" data-tool="line" title="Линия">╱</button>
                        <button class="tool-btn" data-tool="path" title="Путь">✎</button>
                        <button class="tool-btn" data-tool="text" title="Текст">T</button>
                    </div>
                </div>
                
                <div class="tool-group">
                    <h3>Стили</h3>
                    <div class="property">
                        <label for="stroke-color">Цвет обводки</label>
                        <div class="color-picker">
                            <input type="color" id="stroke-color" value="#325980">
                            <div class="color-preview" style="background-color: #325980;"></div>
                        </div>
                    </div>
                    <div class="property">
                        <label for="stroke-width">Толщина обводки</label>
                        <input type="number" id="stroke-width" value="2" min="0" max="20">
                    </div>
                    <div class="property">
                        <label for="fill-color">Цвет заливки</label>
                        <div class="color-picker">
                            <input type="color" id="fill-color" value="#3498db">
                            <div class="color-preview" style="background-color: #3498db;"></div>
                        </div>
                    </div>
                </div>
                 <div class="tool-group">
                    <h3>Редактор SVG-графики</h3>
                   
					<p style="font-size: 14px; margin-bottom: 10px;"><strong>Инструменты:</strong> прямоугольник, круг, линия, путь (✎) или текст (T)</p>
					  <p style="font-size: 14px; margin-bottom: 10px;"><strong>Объекты:</strong> настройка стиля, выбор иснтрумента, создание рисунка, выделение, позиционирование</p>
					  <p style="font-size: 14px; margin-bottom: 10px;"><strong>Тексты:</strong> настройка цвета, размера, ввод содержания, выбор инструмента (Т), вставка в нужное положение</p>
					   <p style="font-size: 14px; margin-bottom: 10px;"><strong>Экспорт:</strong> в форматы PNG и SVG</p>
                </div>
				 
				
                <div class="tool-group">
                    <button id="export-info-btn">О семиотическом переводе</button>
                </div>
            </div>
            
            <div class="canvas-container">
                <svg id="svg-canvas" xmlns="http://www.w3.org/2000/svg" version="1.1">
                    <!-- Здесь будут создаваться SVG-элементы -->
                </svg>
            </div>
            
            <div class="property-panel">
                <div class="property-group">
                    <h3>Свойства элемента</h3>
                    <div class="property">
                        <label for="element-x">Позиция X</label>
                        <input type="number" id="element-x" value="0">
                    </div>
                    <div class="property">
                        <label for="element-y">Позиция Y</label>
                        <input type="number" id="element-y" value="0">
                    </div>
                    <div class="property">
                        <label for="element-width">Ширина</label>
                        <input type="number" id="element-width" value="100">
                    </div>
                    <div class="property">
                        <label for="element-height">Высота</label>
                        <input type="number" id="element-height" value="100">
                    </div>
                </div>
                
                <div class="property-group">
                    <h3>Текст</h3>
                    <div class="property">
                        <label for="text-content">Содержание</label>
                        <input type="text" id="text-content" placeholder="Введите текст">
                    </div>
                    <div class="property">
                        <label for="font-size">Размер шрифта</label>
                        <input type="number" id="font-size" value="16" min="8" max="72">
                    </div>
                </div>
                <div class="property-group">
                <button id="delete-element">Удалить элемент</button>
                </div>
                <div class="property-group">
                <button id="bring-forward">Переместить вперед</button>                
                </div>
				<div class="property-group">
                 <button id="send-backward">Переместить назад</button>
                </div>
				
            </div>
        </div>
    </div>
    
    <!-- Модальное окно для экспорта -->
    <div id="export-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Экспорт изображения</h2>
                <button class="close-modal">&times;</button>
            </div>
            <div class="export-preview">
                <canvas id="export-canvas"></canvas>
            </div>
            <div class="export-options">
                <button id="download-png">Скачать PNG</button>
                <button id="download-svg">Скачать SVG</button>
            </div>
        </div>
    </div>
    
	<!-- Модальное окно с информацией о семиотическом переводе -->
    <div id="info-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
				<h2>О семиотическом переводе</h2>
                <button class="close-modal">&times;</button>
            </div>
            <div>				
				<p>Семиотический перевод — это процесс передачи значения между различными знаковыми системами.</p>
                <p>В контексте компьютерной графики:</p>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li><strong>SVG (Scalable Vector Graphics)</strong> — векторный формат, основанный на XML, где изображение описывается математическими формулами.</li>
                    <li><strong>PNG (Portable Network Graphics)</strong> — растровый формат, где изображение представлено в виде сетки пикселей.</li>
                </ul>
                <p style="margin-top: 15px;">Преобразование из SVG в PNG — это семиотический перевод, при котором происходит трансформация из одной системы знаков (математических формул) в другую (матрицу пикселей).</p>
                <p>Этот процесс аналогичен переводу между естественными языками, где также происходит перекодирование смысла из одной знаковой системы в другую.</p>
            </div>
        </div>
    </div>


<div style="position: fixed; top: 96%; left: 46%; ; color: #333333; opacity: 0.3; font-size: 14px;">© 2025 | kmp | CC BY-NC-SA 4.0</div>
<div style="position: fixed; top: 97%; bottom: 10px; color: #777777; right: 30px; opacity: 0.3; font-size: 14px;">kmp+</div>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Основные переменные
            const svgCanvas = document.getElementById('svg-canvas');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const saveBtn = document.getElementById('save-btn');
            const clearBtn = document.getElementById('clear-btn');
            const exportBtn = document.getElementById('export-btn');
            const exportInfoBtn = document.getElementById('export-info-btn');
            
            // Модальные окна
            const exportModal = document.getElementById('export-modal');
            const infoModal = document.getElementById('info-modal');
            const closeModals = document.querySelectorAll('.close-modal');
            const downloadPngBtn = document.getElementById('download-png');
            const downloadSvgBtn = document.getElementById('download-svg');
            
            // Свойства стилей
            const strokeColorInput = document.getElementById('stroke-color');
            const strokeWidthInput = document.getElementById('stroke-width');
            const fillColorInput = document.getElementById('fill-color');
            
            // Свойства элемента
            const elementXInput = document.getElementById('element-x');
            const elementYInput = document.getElementById('element-y');
            const elementWidthInput = document.getElementById('element-width');
            const elementHeightInput = document.getElementById('element-height');
            
            // Свойства текста
            const textContentInput = document.getElementById('text-content');
            const fontSizeInput = document.getElementById('font-size');
            
            // Кнопки действий
            const bringForwardBtn = document.getElementById('bring-forward');
            const sendBackwardBtn = document.getElementById('send-backward');
            const deleteElementBtn = document.getElementById('delete-element');
            
            // Состояние приложения
            let currentTool = 'select';
            let isDrawing = false;
            let startX = 0;
            let startY = 0;
            let selectedElement = null;
            let currentElement = null;
            let elements = [];
            let nextId = 1;
            
            // Обработчики модальных окон
            exportBtn.addEventListener('click', openExportModal);
            exportInfoBtn.addEventListener('click', function() {
                infoModal.style.display = 'flex';
            });
            
            closeModals.forEach(btn => {
                btn.addEventListener('click', function() {
                    exportModal.style.display = 'none';
                    infoModal.style.display = 'none';
                });
            });
            
            window.addEventListener('click', function(e) {
                if (e.target === exportModal) {
                    exportModal.style.display = 'none';
                }
                if (e.target === infoModal) {
                    infoModal.style.display = 'none';
                }
            });
            
            // Обработчики инструментов
            toolButtons.forEach(button => {
                button.addEventListener('click', function() {
                    toolButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    currentTool = this.getAttribute('data-tool');
                    
                    if (currentTool !== 'select') {
                        deselectElement();
                    }
                });
            });
            
            // Обновление цветовых превью
            strokeColorInput.addEventListener('input', function() {
                document.querySelector('#stroke-color + .color-preview').style.backgroundColor = this.value;
                if (selectedElement) {
                    selectedElement.setAttribute('stroke', this.value);
                }
            });
            
            fillColorInput.addEventListener('input', function() {
                document.querySelector('#fill-color + .color-preview').style.backgroundColor = this.value;
                if (selectedElement) {
                    selectedElement.setAttribute('fill', this.value);
                }
            });
            
            // Обработчики событий для рисования
            svgCanvas.addEventListener('mousedown', startDrawing);
            svgCanvas.addEventListener('mousemove', draw);
            svgCanvas.addEventListener('mouseup', stopDrawing);
            svgCanvas.addEventListener('mouseleave', stopDrawing);
            
            // Функции для рисования
            function startDrawing(e) {
                if (currentTool === 'select') {
                    handleSelection(e);
                    return;
                }
                
                isDrawing = true;
                const rect = svgCanvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;
                
                switch (currentTool) {
                    case 'rect':
                        currentElement = createRectangle(startX, startY, 0, 0);
                        break;
                    case 'circle':
                        currentElement = createCircle(startX, startY, 0);
                        break;
                    case 'line':
                        currentElement = createLine(startX, startY, startX, startY);
                        break;
                    case 'path':
                        currentElement = createPath(startX, startY);
                        break;
                    case 'text':
                        currentElement = createText(startX, startY, textContentInput.value || 'Текст');
                        isDrawing = false; // Для текста нам не нужно продолжать рисование
                        break;
                }
                
                if (currentElement) {
                    svgCanvas.appendChild(currentElement);
                }
            }
            
            function draw(e) {
                if (!isDrawing) return;
                
                const rect = svgCanvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                switch (currentTool) {
                    case 'rect':
                        updateRectangle(currentElement, startX, startY, currentX, currentY);
                        break;
                    case 'circle':
                        const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                        updateCircle(currentElement, startX, startY, radius);
                        break;
                    case 'line':
                        updateLine(currentElement, startX, startY, currentX, currentY);
                        break;
                    case 'path':
                        updatePath(currentElement, currentX, currentY);
                        break;
                }
            }
            
            function stopDrawing() {
                if (!isDrawing) return;
                isDrawing = false;
                
                if (currentElement) {
                    elements.push({
                        id: nextId++,
                        element: currentElement
                    });
                    currentElement = null;
                }
            }
            
            // Функции для создания SVG-элементов
            function createRectangle(x, y, width, height) {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', width);
                rect.setAttribute('height', height);
                rect.setAttribute('stroke', strokeColorInput.value);
                rect.setAttribute('stroke-width', strokeWidthInput.value);
                rect.setAttribute('fill', fillColorInput.value);
                rect.setAttribute('data-type', 'rect');
                return rect;
            }
            
            function updateRectangle(rect, x1, y1, x2, y2) {
                const minX = Math.min(x1, x2);
                const minY = Math.min(y1, y2);
                const width = Math.abs(x2 - x1);
                const height = Math.abs(y2 - y1);
                
                rect.setAttribute('x', minX);
                rect.setAttribute('y', minY);
                rect.setAttribute('width', width);
                rect.setAttribute('height', height);
            }
            
            function createCircle(x, y, radius) {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', radius);
                circle.setAttribute('stroke', strokeColorInput.value);
                circle.setAttribute('stroke-width', strokeWidthInput.value);
                circle.setAttribute('fill', fillColorInput.value);
                circle.setAttribute('data-type', 'circle');
                return circle;
            }
            
            function updateCircle(circle, x, y, radius) {
                circle.setAttribute('r', radius);
            }
            
            function createLine(x1, y1, x2, y2) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', strokeColorInput.value);
                line.setAttribute('stroke-width', strokeWidthInput.value);
                line.setAttribute('data-type', 'line');
                return line;
            }
            
            function updateLine(line, x1, y1, x2, y2) {
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
            }
            
            function createPath(x, y) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${x} ${y}`);
                path.setAttribute('stroke', strokeColorInput.value);
                path.setAttribute('stroke-width', strokeWidthInput.value);
                path.setAttribute('fill', 'none');
                path.setAttribute('data-type', 'path');
                return path;
            }
            
            function updatePath(path, x, y) {
                const d = path.getAttribute('d') + ` L ${x} ${y}`;
                path.setAttribute('d', d);
            }
            
            function createText(x, y, text) {
                const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textElement.setAttribute('x', x);
                textElement.setAttribute('y', y);
                textElement.setAttribute('font-size', fontSizeInput.value);
                textElement.setAttribute('fill', fillColorInput.value);
                textElement.setAttribute('data-type', 'text');
                textElement.textContent = text;
                return textElement;
            }
            
            // Функции для выбора и работы с элементами
            function handleSelection(e) {
                const rect = svgCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Перебираем элементы в обратном порядке (сверху вниз)
                for (let i = elements.length - 1; i >= 0; i--) {
                    const element = elements[i].element;
                    if (isPointInElement(element, x, y)) {
                        selectElement(element);
                        return;
                    }
                }
                
                deselectElement();
            }
            
            function isPointInElement(element, x, y) {
                const type = element.getAttribute('data-type');
                
                switch (type) {
                    case 'rect':
                        const rectX = parseFloat(element.getAttribute('x'));
                        const rectY = parseFloat(element.getAttribute('y'));
                        const rectWidth = parseFloat(element.getAttribute('width'));
                        const rectHeight = parseFloat(element.getAttribute('height'));
                        return x >= rectX && x <= rectX + rectWidth && y >= rectY && y <= rectY + rectHeight;
                    
                    case 'circle':
                        const cx = parseFloat(element.getAttribute('cx'));
                        const cy = parseFloat(element.getAttribute('cy'));
                        const r = parseFloat(element.getAttribute('r'));
                        return Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2)) <= r;
                    
                    case 'line':
                        const x1 = parseFloat(element.getAttribute('x1'));
                        const y1 = parseFloat(element.getAttribute('y1'));
                        const x2 = parseFloat(element.getAttribute('x2'));
                        const y2 = parseFloat(element.getAttribute('y2'));
                        const lineWidth = parseFloat(element.getAttribute('stroke-width'));
                        
                        // Расстояние от точки до линии
                        const distance = Math.abs((y2 - y1) * x - (x2 - x1) * y + x2 * y1 - y2 * x1) / 
                                        Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));
                        
                        return distance <= lineWidth + 5;
                    
                    case 'text':
                        const textX = parseFloat(element.getAttribute('x'));
                        const textY = parseFloat(element.getAttribute('y'));
                        const fontSize = parseFloat(element.getAttribute('font-size'));
                        const textWidth = element.getComputedTextLength ? element.getComputedTextLength() : 100;
                        
                        return x >= textX && x <= textX + textWidth && y >= textY - fontSize && y <= textY;
                    
                    default:
                        return false;
                }
            }
            
            function selectElement(element) {
                deselectElement();
                selectedElement = element;
                element.setAttribute('stroke-dasharray', '5,5');
                updatePropertyPanel(element);
            }
            
            function deselectElement() {
                if (selectedElement) {
                    selectedElement.removeAttribute('stroke-dasharray');
                    selectedElement = null;
                    clearPropertyPanel();
                }
            }
            
            function updatePropertyPanel(element) {
                const type = element.getAttribute('data-type');
                
                // Обновляем общие стили
                strokeColorInput.value = element.getAttribute('stroke') || '#325980';
                document.querySelector('#stroke-color + .color-preview').style.backgroundColor = strokeColorInput.value;
                
                strokeWidthInput.value = element.getAttribute('stroke-width') || '2';
                
                if (element.getAttribute('fill')) {
                    fillColorInput.value = element.getAttribute('fill');
                    document.querySelector('#fill-color + .color-preview').style.backgroundColor = fillColorInput.value;
                }
                
                // Обновляем свойства в зависимости от типа элемента
                switch (type) {
                    case 'rect':
                        elementXInput.value = element.getAttribute('x');
                        elementYInput.value = element.getAttribute('y');
                        elementWidthInput.value = element.getAttribute('width');
                        elementHeightInput.value = element.getAttribute('height');
                        break;
                    
                    case 'circle':
                        elementXInput.value = element.getAttribute('cx');
                        elementYInput.value = element.getAttribute('cy');
                        elementWidthInput.value = element.getAttribute('r');
                        elementHeightInput.value = element.getAttribute('r');
                        break;
                    
                    case 'line':
                        elementXInput.value = element.getAttribute('x1');
                        elementYInput.value = element.getAttribute('y1');
                        elementWidthInput.value = element.getAttribute('x2');
                        elementHeightInput.value = element.getAttribute('y2');
                        break;
                    
                    case 'text':
                        elementXInput.value = element.getAttribute('x');
                        elementYInput.value = element.getAttribute('y');
                        textContentInput.value = element.textContent;
                        fontSizeInput.value = element.getAttribute('font-size');
                        break;
                }
            }
            
            function clearPropertyPanel() {
                elementXInput.value = '0';
                elementYInput.value = '0';
                elementWidthInput.value = '100';
                elementHeightInput.value = '100';
                textContentInput.value = '';
                fontSizeInput.value = '16';
            }
            
            // Обработчики изменения свойств
            elementXInput.addEventListener('change', updateElementProperty);
            elementYInput.addEventListener('change', updateElementProperty);
           elementWidthInput.addEventListener('change', updateElementProperty);
            elementHeightInput.addEventListener('change', updateElementProperty);
            textContentInput.addEventListener('change', updateElementProperty);
            fontSizeInput.addEventListener('change', updateElementProperty);
            
            function updateElementProperty() {
                if (!selectedElement) return;
                
                const type = selectedElement.getAttribute('data-type');
                
                switch (type) {
                    case 'rect':
                        selectedElement.setAttribute('x', elementXInput.value);
                        selectedElement.setAttribute('y', elementYInput.value);
                        selectedElement.setAttribute('width', elementWidthInput.value);
                        selectedElement.setAttribute('height', elementHeightInput.value);
                        break;
                    
                    case 'circle':
                        selectedElement.setAttribute('cx', elementXInput.value);
                        selectedElement.setAttribute('cy', elementYInput.value);
                        selectedElement.setAttribute('r', elementWidthInput.value);
                        break;
                    
                    case 'line':
                        selectedElement.setAttribute('x1', elementXInput.value);
                        selectedElement.setAttribute('y1', elementYInput.value);
                        selectedElement.setAttribute('x2', elementWidthInput.value);
                        selectedElement.setAttribute('y2', elementHeightInput.value);
                        break;
                    
                    case 'text':
                        selectedElement.setAttribute('x', elementXInput.value);
                        selectedElement.setAttribute('y', elementYInput.value);
                        selectedElement.textContent = textContentInput.value;
                        selectedElement.setAttribute('font-size', fontSizeInput.value);
                        break;
                }
            }
            
            // Обработчики кнопок действий
            bringForwardBtn.addEventListener('click', function() {
                if (!selectedElement) return;
                
                // Найти элемент в массиве
                const index = elements.findIndex(item => item.element === selectedElement);
                if (index < elements.length - 1) {
                    // Поменять местами с элементом выше
                    const temp = elements[index];
                    elements[index] = elements[index + 1];
                    elements[index + 1] = temp;
                    
                    // Перерисовать SVG
                    redrawCanvas();
                }
            });
            
            sendBackwardBtn.addEventListener('click', function() {
                if (!selectedElement) return;
                
                // Найти элемент в массиве
                const index = elements.findIndex(item => item.element === selectedElement);
                if (index > 0) {
                    // Поменять местами с элементом ниже
                    const temp = elements[index];
                    elements[index] = elements[index - 1];
                    elements[index - 1] = temp;
                    
                    // Перерисовать SVG
                    redrawCanvas();
                }
            });
            
            deleteElementBtn.addEventListener('click', function() {
                if (!selectedElement) return;
                
                // Найти и удалить элемент из массива
                const index = elements.findIndex(item => item.element === selectedElement);
                if (index !== -1) {
                    elements.splice(index, 1);
                    
                    // Удалить элемент из SVG и сбросить выделение
                    svgCanvas.removeChild(selectedElement);
                    selectedElement = null;
                    clearPropertyPanel();
                }
            });
            
            function redrawCanvas() {
                // Очистить холст
                while (svgCanvas.firstChild) {
                    svgCanvas.removeChild(svgCanvas.firstChild);
                }
                
                // Перерисовать все элементы
                elements.forEach(item => {
                    svgCanvas.appendChild(item.element);
                });
                
                // Восстановить выделение
                if (selectedElement) {
                    selectElement(selectedElement);
                }
            }
            
            // Сохранение и очистка
            saveBtn.addEventListener('click', function() {
                // Создаем копию SVG для сохранения
                const svgClone = svgCanvas.cloneNode(true);
                
                // Удаляем выделение
                const selectedElements = svgClone.querySelectorAll('[stroke-dasharray]');
                selectedElements.forEach(el => el.removeAttribute('stroke-dasharray'));
                
                // Создаем строку SVG
                const svgData = new XMLSerializer().serializeToString(svgClone);
                
                // Создаем Blob и ссылку для скачивания
                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                
                // Создаем временную ссылку для скачивания
                const a = document.createElement('a');
                a.href = url;
                a.download = 'drawing.svg';
                document.body.appendChild(a);
                a.click();
                
                // Очищаем ресурсы
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 0);
            });
            
            clearBtn.addEventListener('click', function() {
                if (confirm('Вы уверены, что хотите очистить холст?')) {
                    // Очистить массив элементов
                    elements = [];
                    
                    // Очистить холст
                    while (svgCanvas.firstChild) {
                        svgCanvas.removeChild(svgCanvas.firstChild);
                    }
                    
                    // Сбросить выделение
                    selectedElement = null;
                    clearPropertyPanel();
                }
            });
            
            // Функции экспорта в PNG
            function openExportModal() {
                // Подготовить SVG для экспорта
                const svgClone = svgCanvas.cloneNode(true);
                
                // Удаляем выделение
                const selectedElements = svgClone.querySelectorAll('[stroke-dasharray]');
                selectedElements.forEach(el => el.removeAttribute('stroke-dasharray'));
                
                // Получаем размеры SVG
                const svgBounds = svgCanvas.getBoundingClientRect();
                const width = svgBounds.width;
                const height = svgBounds.height;
                
                // Создаем строку SVG для конвертации в PNG
                const svgData = new XMLSerializer().serializeToString(svgClone);
                const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);
                
                // Создаем изображение и холст для конвертации
                const img = new Image();
                const canvas = document.getElementById('export-canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                
                img.onload = function() {
                    // Заполняем холст белым фоном
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, width, height);
                    
                    // Рисуем SVG на холсте
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Освобождаем ресурсы
                    URL.revokeObjectURL(url);
                    
                    // Показываем модальное окно
                    exportModal.style.display = 'flex';
                };
                
                img.src = url;
            }
            
            // Обработчики кнопок экспорта
            downloadPngBtn.addEventListener('click', function() {
               const canvas = document.getElementById('export-canvas');
                const pngUrl = canvas.toDataURL('image/png');
                
                // Создаем ссылку для скачивания
                const a = document.createElement('a');
                a.href = pngUrl;
                a.download = 'drawing.png';
                document.body.appendChild(a);
                a.click();
                
                // Очищаем ресурсы
                setTimeout(() => {
                    document.body.removeChild(a);
                }, 0);
                
                // Закрываем модальное окно
                exportModal.style.display = 'none';
            });
            
            downloadSvgBtn.addEventListener('click', function() {
                // Создаем копию SVG для сохранения
                const svgClone = svgCanvas.cloneNode(true);
                
                // Удаляем выделение
                const selectedElements = svgClone.querySelectorAll('[stroke-dasharray]');
                selectedElements.forEach(el => el.removeAttribute('stroke-dasharray'));
                
                // Создаем строку SVG
                const svgData = new XMLSerializer().serializeToString(svgClone);
                
                // Создаем Blob и ссылку для скачивания
                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                
                // Создаем временную ссылку для скачивания
                const a = document.createElement('a');
                a.href = url;
                a.download = 'drawing.svg';
                document.body.appendChild(a);
                a.click();
                
                // Очищаем ресурсы
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 0);
                
                // Закрываем модальное окно
                exportModal.style.display = 'none';
            });

            // Добавляем семиотическую информацию в модальном окне
            function showSemioticInfo() {
                // При экспорте показываем информацию о семиотическом переводе
                const exportInfoText = document.createElement('div');
                exportInfoText.classList.add('semiotic-info');
                exportInfoText.innerHTML = `
                    <p><strong>Семиотический перевод:</strong> векторный формат (SVG) → растровый формат (PNG)</p>
                    <p>Этот процесс аналогичен переводу между языками, где происходит трансформация смысла из одной системы знаков в другую.</p>
                `;
                
                // Добавляем в модальное окно
                const modalContent = document.querySelector('#export-modal .modal-content');
                modalContent.appendChild(exportInfoText);
            }
        });
    </script>
</body>
</html>