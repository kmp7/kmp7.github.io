<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="keywords" content="Разработка Орловой Е.А.">
	<meta name="description" content="Разработка Евы Адамовны">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Разработка Орловой</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f0f2f5;
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            width: 100%;
        }

        .input-container {
            margin-bottom: 20px;
            text-align: center;
        }

        input {
            padding: 10px;
            font-size: 16px;
            width: 200px;
            border: 2px solid #4a90e2;
            border-radius: 5px;
            margin-right: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #357abd;
        }

        #network {
            width: 100%;
            height: 500px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        .node {
            position: absolute;
            background: #4a90e2;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: move;
            user-select: none;
            font-size: 14px;
            transition: transform 0.1s;
            transform: translate(-50%, -50%);
            z-index: 2;
        }

        .node.central {
            background: #e24a4a;
        }

        .node:hover {
            transform: translate(-50%, -50%) scale(1.1);
        }

        .weight-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 12px;
            color: #666;
            transform: translate(-50%, -50%);
            z-index: 1;
            border: 1px solid #ddd;
        }

        .weights-table {
            margin-top: 20px;
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .weights-table th,
        .weights-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .weights-table th {
            background: #4a90e2;
            color: white;
        }

        .weights-table tr:hover {
            background: #f5f8ff;
        }

        .weights-container {
            margin-top: 20px;
            width: 100%;
        }

        /* Стили для модального окна */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .modal-content button {
            margin-top: 10px;
            padding: 10px 20px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .modal-content button:hover {
            background: #357abd;
        }
    </style>
    <title>OrlovaEA</title>
</head>
<body>
    <div class="container">
        <div class="input-container">
            <input type="text" id="wordInput" placeholder="Введите слово">
            <button onclick="generateNetwork()">Показать ассоциации</button>
        </div>
        <div id="network">
            <canvas id="connections"></canvas>
        </div>
        <div class="weights-container" id="weightsContainer"></div>
    </div>

    <!-- Модальное окно -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <p id="modal-message"></p>
            <button onclick="closeModal()">Закрыть</button>
        </div>
    </div>

    <script>
        const semanticModel = {
            'орлова': {
                associates: [
                    {word: 'Ум', weight: 0.5},
                    {word: 'Красота', weight: 0.3},
                    {word: 'Нежность', weight: 0.6},
                    {word: 'Доброта', weight: 1.0},
                    {word: 'Сила', weight: 0.2},
                    {word: 'Радость', weight: 0.7},
                    {word: 'Строгость', weight: 0.4},
                    {word: 'Здоровье', weight: 0.5},
                    {word: 'Верность', weight: 0.8},
                    {word: 'Любовь', weight: 1.1}
                ],
                original: 'Орлова'
            },
            'nlp': {
                associates: [
                    {word: 'Текст', weight: 0.9},
                    {word: 'Анализ', weight: 0.8},
                    {word: 'Язык', weight: 0.8},
                    {word: 'Модель', weight: 0.7},
                    {word: 'Алгоритм', weight: 0.7},
                    {word: 'Данные', weight: 0.6},
                    {word: 'Машинное обучение', weight: 0.6},
                    {word: 'Токенизация', weight: 0.5},
                    {word: 'Семантика', weight: 0.5},
                    {word: 'Программирование', weight: 0.4}
                ],
                original: 'NLP'
            },
            'дом': {
                associates: [
                    {word: 'Квартира', weight: 0.9},
                    {word: 'Здание', weight: 0.8},
                    {word: 'Жилище', weight: 0.8},
                    {word: 'Комната', weight: 0.7},
                    {word: 'Крыша', weight: 0.6},
                    {word: 'Стены', weight: 0.6},
                    {word: 'Окна', weight: 0.5},
                    {word: 'Дверь', weight: 0.5},
                    {word: 'Уют', weight: 0.4},
                    {word: 'Семья', weight: 0.4}
                ],
                original: 'Дом'
            },
            'книга': {
                associates: [
                    {word: 'Автор', weight: 0.9},
                    {word: 'Книга', weight: 0.8},
                    {word: 'Литература', weight: 0.8},
                    {word: 'Текст', weight: 0.7},
                    {word: 'Роман', weight: 0.7},
                    {word: 'Писатель', weight: 0.6},
                    {word: 'Библиотека', weight: 0.5},
                    {word: 'Чтение', weight: 0.5},
                    {word: 'Произведение', weight: 0.4},
                    {word: 'Страница', weight: 0.4}
                ],
                original: 'Книга'
            }
        };

        class Node {
            constructor(word, x, y, isCentral, weight = 1) {
                this.word = word;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.isCentral = isCentral;
                this.weight = weight;
                this.element = null;
                this.weightLabel = null;
            }
        }

        let nodes = [];
        let isDragging = false;
        let currentNode = null;
        let animation = null;
        const springLength = 150;
        const springStrength = 0.05;
        const repulsion = 1000;
        const damping = 0.8;

        function showModal(message) {
            const modal = document.getElementById('modal');
            const modalMessage = document.getElementById('modal-message');
            modalMessage.textContent = message;
            modal.style.display = 'flex';
        }

        function closeModal() {
            const modal = document.getElementById('modal');
            modal.style.display = 'none';
        }

        function generateWeightsTable(word, associates) {
            const container = document.getElementById('weightsContainer');
            container.innerHTML = `
                <table class="weights-table">
                    <thead>
                        <tr>
                            <th>Ассоциация</th>
                            <th>Семантическая близость</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${associates.map(associate => `
                            <tr>
                                <td>${associate.word}</td>
                                <td>${associate.weight.toFixed(2)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function generateNetwork() {
            const inputWord = document.getElementById('wordInput').value;
            const word = inputWord.toLowerCase();
            const network = document.getElementById('network');
            
            network.innerHTML = '<canvas id="connections"></canvas>';
            if (animation) cancelAnimationFrame(animation);
            nodes = [];

            if (!semanticModel[word]) {
                showModal('Извините, это слово пока не в моей базе. Попробуйте: книга, NLP, дом, Орлова');
                return;
            }

            const centerX = network.offsetWidth / 2;
            const centerY = network.offsetHeight / 2;
            
            nodes.push(new Node(semanticModel[word].original, centerX, centerY, true));

            const associates = semanticModel[word].associates;
            associates.forEach((associate, i) => {
                const angle = (i / associates.length) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * springLength;
                const y = centerY + Math.sin(angle) * springLength;
                nodes.push(new Node(associate.word, x, y, false, associate.weight));
            });

            nodes.forEach(node => createNodeElement(node));
            generateWeightsTable(word, associates);

            const canvas = document.getElementById('connections');
            canvas.width = network.offsetWidth;
            canvas.height = network.offsetHeight;

            animate();
        }

        function createNodeElement(node) {
            const network = document.getElementById('network');
            const element = document.createElement('div');
            element.className = 'node' + (node.isCentral ? ' central' : '');
            element.textContent = node.word;
            element.style.left = node.x + 'px';
            element.style.top = node.y + 'px';

            if (!node.isCentral) {
                const weightLabel = document.createElement('div');
                weightLabel.className = 'weight-label';
                weightLabel.textContent = node.weight.toFixed(2);
                weightLabel.style.left = node.x + 'px';
                weightLabel.style.top = node.y + 'px';
                node.weightLabel = weightLabel;
                network.appendChild(weightLabel);
            }

            element.addEventListener('mousedown', function(e) {
                isDragging = true;
                currentNode = node;
                const rect = element.getBoundingClientRect();
                const offsetX = e.clientX - rect.left - rect.width / 2;
                const offsetY = e.clientY - rect.top - rect.height / 2;
                
                function mouseMoveHandler(e) {
                    const networkRect = network.getBoundingClientRect();
                    node.x = e.clientX - networkRect.left - offsetX;
                    node.y = e.clientY - networkRect.top - offsetY;
                    if (node.weightLabel) {
                        node.weightLabel.style.left = node.x + 'px';
                        node.weightLabel.style.top = node.y + 'px';
                    }
                    node.vx = 0;
                    node.vy = 0;
                }

                function mouseUpHandler() {
                    isDragging = false;
                    currentNode = null;
                    document.removeEventListener('mousemove', mouseMoveHandler);
                    document.removeEventListener('mouseup', mouseUpHandler);
                }

                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);
            });

            node.element = element;
            network.appendChild(element);
        }

        function updatePhysics() {
            for (let i = 0; i < nodes.length; i++) {
                const node1 = nodes[i];
                if (node1 === currentNode) continue;

                for (let j = i + 1; j < nodes.length; j++) {
                    const node2 = nodes[j];
                    if (node2 === currentNode) continue;

                    const dx = node2.x - node1.x;
                    const dy = node2.y - node1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const repulsiveForce = repulsion / (distance * distance);
                    const forceX = (dx / distance) * repulsiveForce;
                    const forceY = (dy / distance) * repulsiveForce;

                    let attractiveForce = 0;
                    if (node1.isCentral || node2.isCentral) {
                        const weight = node1.isCentral ? node2.weight : node1.weight;
                        const desiredLength = springLength * (1.5 - weight);
                        const displacement = distance - desiredLength;
                        attractiveForce = springStrength * displacement * weight;
                    }

                    const totalForceX = forceX - (dx / distance) * attractiveForce;
                    const totalForceY = forceY - (dy / distance) * attractiveForce;

                    if (!node1.isCentral) {
                        node1.vx -= totalForceX;
                        node1.vy -= totalForceY;
                    }
                    if (!node2.isCentral) {
                        node2.vx += totalForceX;
                        node2.vy += totalForceY;
                    }
                }
            }

            const network = document.getElementById('network');
            const padding = 50;

            nodes.forEach(node => {
                if (node === currentNode) return;

                node.vx *= damping;
                node.vy *= damping;

                node.x += node.vx;
                node.y += node.vy;

                node.x = Math.max(padding, Math.min(network.offsetWidth - padding, node.x));
                node.y = Math.max(padding, Math.min(network.offsetHeight - padding, node.y));

                node.element.style.left = node.x + 'px';
                node.element.style.top = node.y + 'px';

                if (node.weightLabel) {
                    node.weightLabel.style.left = node.x + 'px';
                    node.weightLabel.style.top = node.y + 'px';
                }
            });
        }

        function drawConnections() {
            const canvas = document.getElementById('connections');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centralNode = nodes.find(node => node.isCentral);
            if (!centralNode) return;

            nodes.forEach(node => {
                if (!node.isCentral) {
                    ctx.beginPath();
                    ctx.moveTo(centralNode.x, centralNode.y);
                    ctx.lineTo(node.x, node.y);
                    ctx.strokeStyle = `rgba(74, 144, 226, ${node.weight})`;
                    ctx.lineWidth = node.weight * 3;
                    ctx.stroke();
                }
            });
        }

        function animate() {
            updatePhysics();
            drawConnections();
            animation = requestAnimationFrame(animate);
        }

        window.onload = function() {
            const canvas = document.getElementById('connections');
            const network = document.getElementById('network');
            canvas.width = network.offsetWidth;
            canvas.height = network.offsetHeight;
        };
    </script>
</body>
</html>